---
phase: 31-end-to-end-test-implementation
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/routes/test-utils.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "simulate-webhook endpoint accepts 'subscription.activated' and delegates to handlePaymentSuccess"
    - "simulate-webhook endpoint accepts 'agent.confirmed' and updates KV challenge status to awaiting-payment"
    - "POST /create-agent endpoint inserts an agent row into D1 for E2E test setup"
  artifacts:
    - path: "backend/src/routes/test-utils.ts"
      provides: "subscription.activated case, agent.confirmed case, POST /create-agent endpoint"
      contains: "case 'subscription.activated'"
  key_links:
    - from: "test/e2e/subscription-flow.spec.ts"
      to: "backend/src/routes/test-utils.ts"
      via: "simulateWebhook({ event_type: 'subscription.activated' })"
      pattern: "case 'subscription\\.activated'"
    - from: "test/e2e/shadow-claim.spec.ts"
      to: "backend/src/routes/test-utils.ts"
      via: "simulateWebhook({ event_type: 'agent.confirmed' })"
      pattern: "case 'agent\\.confirmed'"
    - from: "test/e2e/shadow-claim.spec.ts"
      to: "backend/src/routes/test-utils.ts"
      via: "request.post('/v1/test-utils/create-agent')"
      pattern: "testUtils\\.post\\('/create-agent'"
---

<objective>
Close 3 verification gaps in test-utils.ts that block E2E test execution.

Purpose: subscription-flow.spec.ts and shadow-claim.spec.ts send event types and call endpoints that test-utils.ts does not handle, causing 400 errors. All 3 gaps are additive changes to a single file.
Output: Updated test-utils.ts with all event types and endpoints the E2E specs require.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-end-to-end-test-implementation/31-VERIFICATION.md

@backend/src/routes/test-utils.ts
@backend/src/services/webhook-handler.ts
@backend/src/services/shadowClaimService.ts
@backend/src/db/schema/agents.ts
@test/e2e/subscription-flow.spec.ts
@test/e2e/shadow-claim.spec.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add missing event types and create-agent endpoint to test-utils.ts</name>
  <files>backend/src/routes/test-utils.ts</files>
  <action>
Make 3 additive changes to `backend/src/routes/test-utils.ts`:

**1. Add `subscription.activated` case to the simulate-webhook switch (between `customer.created` and `default`):**

```typescript
case 'subscription.activated':
  await handlePaymentSuccess(data, c.env.DB, c.env);
  break;
```

`handlePaymentSuccess` is already imported at line 8. This mirrors how the real webhooks.ts handles this event. The E2E test `subscription-flow.spec.ts` (line 82) sends this event type with `{ subscription_id, customer_id, custom_data: { overseer_id } }` which matches the `PaddlePaymentPayload` interface.

**2. Add `agent.confirmed` case to the simulate-webhook switch (after `subscription.activated`):**

This is a test-only internal event used by `shadow-claim.spec.ts` (line 74) to simulate the agent confirmation step. It sends `{ challenge_id, agent_id }`. The handler must:
- Read the challenge from KV using key `claim:${data.challenge_id}`
- Parse the JSON
- Update `status` to `'awaiting-payment'` and set `updated_at`
- Write it back to KV with the same key (preserve existing TTL by using `expirationTtl: 3600`)

```typescript
case 'agent.confirmed': {
  const challengeKey = `claim:${data.challenge_id}`;
  const existing = await c.env.CHALLENGES.get(challengeKey);
  if (!existing) {
    return c.json({ success: false, error: 'Challenge not found' }, 404);
  }
  const challenge = JSON.parse(existing);
  challenge.status = 'awaiting-payment';
  challenge.updated_at = new Date().toISOString();
  await c.env.CHALLENGES.put(challengeKey, JSON.stringify(challenge), { expirationTtl: 3600 });
  break;
}
```

**3. Add `POST /create-agent` route BEFORE the `/simulate-webhook` route:**

`shadow-claim.spec.ts` (line 33) calls `POST /v1/test-utils/create-agent` with `{ id, name, public_key }`. Insert directly into agents table using Drizzle. The `agents` table is already imported at line 4.

```typescript
testUtils.post('/create-agent', async (c) => {
  try {
    const { id, name, public_key } = await c.req.json();
    const drizzleDb = createDB(c.env.DB);
    const now = new Date().toISOString();
    await drizzleDb.insert(agents).values({
      id,
      name,
      public_key,
      created_at: now,
      updated_at: now,
    });
    return c.json({ success: true, id });
  } catch (error) {
    return c.json({ success: false, error: error instanceof Error ? error.message : 'Create agent failed' }, 500);
  }
});
```

**Do NOT:**
- Modify any existing switch cases — they are verified correct
- Change the middleware or other existing endpoints
- Add new imports — `handlePaymentSuccess`, `agents`, and `createDB` are already imported
  </action>
  <verify>
1. `grep -c "subscription.activated" backend/src/routes/test-utils.ts` returns 1
2. `grep -c "agent.confirmed" backend/src/routes/test-utils.ts` returns 1
3. `grep -c "create-agent" backend/src/routes/test-utils.ts` returns 1
4. `npx tsc --noEmit --project backend/tsconfig.json` passes (no type errors)
5. The switch statement now has 10 cases: the original 7 + subscription.activated + agent.confirmed, plus the default
  </verify>
  <done>
- simulate-webhook accepts `subscription.activated` and calls `handlePaymentSuccess` (unblocks subscription-flow.spec.ts line 82)
- simulate-webhook accepts `agent.confirmed` and updates KV challenge to `awaiting-payment` (unblocks shadow-claim.spec.ts line 74)
- POST /create-agent inserts agent row into D1 (unblocks shadow-claim.spec.ts line 33)
- All 3 verification gaps from 31-VERIFICATION.md are closed
  </done>
</task>

</tasks>

<verification>
1. `grep "case 'subscription.activated'" backend/src/routes/test-utils.ts` — must match
2. `grep "case 'agent.confirmed'" backend/src/routes/test-utils.ts` — must match
3. `grep "'/create-agent'" backend/src/routes/test-utils.ts` — must match
4. TypeScript compilation succeeds with no errors
5. All event types sent by E2E specs (`subscription.activated`, `agent.confirmed`, `transaction.completed`) have matching cases in the switch
6. The `/create-agent` endpoint accepts the exact payload shape from shadow-claim.spec.ts: `{ id, name, public_key }`
</verification>

<success_criteria>
- test-utils.ts simulate-webhook switch handles all event types used by E2E test specs
- test-utils.ts has POST /create-agent endpoint for E2E agent seeding
- No TypeScript compilation errors
- All 3 gaps from 31-VERIFICATION.md are addressed
</success_criteria>

<output>
After completion, create `.planning/phases/31-end-to-end-test-implementation/31-05-SUMMARY.md`
</output>
