---
phase: 35-agent-demo-oauth
plan: 02
type: execute
wave: 2
depends_on:
  - 35-01
files_modified:
  - demo/agent/agent-demo.py
autonomous: true
must_haves:
  truths:
    - "User can initiate OAuth authorization with client ID and redirect URI"
    - "User must provide PKCE code challenge via --code-challenge flag"
    - "Authorization code is printed to stdout in raw JSON format"
    - "Script auto-selects Bearer session or DPoP authentication"
  artifacts:
    - path: "demo/agent/agent-demo.py"
      provides: "authorize subcommand with PKCE support"
      contains: "def cmd_authorize"
  key_links:
    - from: "cmd_authorize"
      to: "POST /v1/oauth/authorize"
      via: "make_request with Bearer or DPoP auth"
      pattern: "oauth/authorize"
    - from: "cmd_authorize"
      to: "print_output"
      via: "authorization code to stdout"
      pattern: "print_output"
---

<objective>
Add `authorize` subcommand to agent-demo.py with PKCE code challenge support.

Purpose: Enable agents to initiate OAuth authorization and receive authorization codes (AOAUTH-02).
Output: Working `authorize` CLI subcommand that prints authorization code to stdout.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/35-agent-demo-oauth/35-CONTEXT.md
@.planning/phases/35-agent-demo-oauth/35-RESEARCH.md
@.planning/phases/35-agent-demo-oauth/35-01-SUMMARY.md
@demo/agent/agent-demo.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add authorize subcommand with PKCE support</name>
  <files>demo/agent/agent-demo.py</files>
  <action>
Add the `authorize` subcommand to agent-demo.py following these specifications:

**CLI Arguments:**
- `--client-id` (required): OAuth client ID (UUID)
- `--redirect-uri` (required): Redirect URI registered with the client
- `--code-challenge` (required): PKCE code challenge from client app (S256 method)
- `--scope` (optional): Space-separated scopes, defaults to "id name description subscription"
- `--state` (optional): State parameter for CSRF protection

**Implementation Details:**

1. Add `authorize` subparser to argparse (after register-client subparser):
```python
# authorize command
parser_authorize = subparsers.add_parser(
    "authorize",
    help="Initiate OAuth authorization for a client",
)
parser_authorize.add_argument("--client-id", required=True, help="OAuth client ID (UUID)")
parser_authorize.add_argument("--redirect-uri", required=True, help="Redirect URI registered with client")
parser_authorize.add_argument("--code-challenge", required=True, help="PKCE code challenge (S256)")
parser_authorize.add_argument("--scope", help="Space-separated scopes")
parser_authorize.add_argument("--state", help="State parameter for CSRF protection")
```

2. Add `cmd_authorize` function (after cmd_register_client):
```python
def cmd_authorize(args) -> int:
    """Initiate OAuth authorization for a client."""
    config = load_config()

    # Validate required config
    if not config.get("backend_url"):
        print("No backend_url configured.", file=sys.stderr)
        return 1

    has_session = bool(config.get("session_id"))
    has_keys = bool(config.get("private_key") and config.get("public_key"))

    if not has_session and not has_keys:
        print(
            "Authentication required: set session_id or private_key + public_key in .env.",
            file=sys.stderr
        )
        return 1

    backend_url = config["backend_url"]
    url = f"{backend_url}/v1/oauth/authorize"

    # Build request body
    body = {
        "client_id": args.client_id,
        "redirect_uri": args.redirect_uri,
        "code_challenge": args.code_challenge,
        "code_challenge_method": "S256",  # Hardcoded per CONTEXT.md
    }

    scope = args.scope or "id name description subscription"
    body["scope"] = scope

    if args.state:
        body["state"] = args.state

    # Build headers with dual auth pattern
    headers = {"Content-Type": "application/json"}

    if has_session:
        # Prefer Bearer session auth
        headers["Authorization"] = f"Bearer {config['session_id']}"
    else:
        # Fall back to DPoP proof
        private_key = load_private_key(config["private_key"])
        dpop_proof = create_dpop_proof(private_key, "POST", url)
        headers["DPoP"] = dpop_proof
        # DPoP auth requires agent_id in body
        if config.get("agent_id"):
            body["agent_id"] = config["agent_id"]

    encoded_body = json.dumps(body).encode("utf-8")

    response = make_request(url, headers, data=encoded_body, method="POST")

    # Output authorization code via print_output (per CONTEXT.md)
    print_output(response)
    return 0
```

3. Add handler to command_handlers dict:
```python
"authorize": cmd_authorize,
```

**Key Patterns to Follow:**
- Use existing `make_request()` for fail-fast HTTP calls
- Use existing `print_output()` for raw JSON output (per CONTEXT.md decision 3)
- Use dual auth pattern from `cmd_claim`: prefer Bearer session, fall back to DPoP
- Use existing `create_dpop_proof()` for DPoP authentication
- Hardcode `code_challenge_method: "S256"` (per CONTEXT.md decision 2)

**DO NOT:**
- Do NOT generate PKCE code challenge - client app provides it (CONTEXT.md decision 2)
- Do NOT redirect, open browser, or save to file - print to stdout only (CONTEXT.md decision 3)
- Do NOT add code_challenge_method flag - always S256 (CONTEXT.md decision 2)
  </action>
  <verify>
    # Verify syntax
    python -m py_compile demo/agent/agent-demo.py

    # Verify CLI help
    python demo/agent/agent-demo.py authorize --help

    # Verify arguments are present
    python demo/agent/agent-demo.py authorize --help | grep -E "(--client-id|--redirect-uri|--code-challenge|--scope|--state)"
  </verify>
  <done>
    - `python agent-demo.py authorize --help` shows all required arguments
    - Subcommand compiles without errors
    - Dual auth pattern implemented (Bearer preferred, DPoP fallback)
    - Authorization code printed to stdout via print_output()
  </done>
</task>

</tasks>

<verification>
Run `python demo/agent/agent-demo.py --help` and verify `authorize` appears in available commands.
Run `python demo/agent/agent-demo.py authorize --help` and verify --client-id, --redirect-uri, --code-challenge are required.
Verify dual auth pattern: code checks session_id first, falls back to private_key + create_dpop_proof.
</verification>

<success_criteria>
- AOAUTH-02 complete: User can initiate OAuth authorization for a client, receiving authorization code.
- CLI help shows authorize with required --client-id, --redirect-uri, --code-challenge flags.
- Authorization response printed to stdout in raw JSON format.
- Dual auth pattern: Bearer session preferred, DPoP fallback when session unavailable.
</success_criteria>

<output>
After completion, create `.planning/phases/35-agent-demo-oauth/35-02-SUMMARY.md`
</output>
