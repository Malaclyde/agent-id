# Phase 35: Agent Demo - OAuth Client - Research

**Researched:** 2026-02-22
**Domain:** OAuth 2.0 Client Registration and Authorization Flow (Python CLI)
**Confidence:** HIGH

## Summary

This phase implements OAuth client registration and authorization initiation for the agent demo script. The agent demo will allow users to register OAuth clients with their agent identity and initiate OAuth authorization flows to receive authorization codes (which can then be exchanged for tokens by a client application).

The backend provides REST endpoints for client registration (`POST /v1/clients/register/agent`) and OAuth authorization (`POST /v1/oauth/authorize`). The CLI needs to handle key management using server-generated client IDs as namespaces in .env, accept PKCE code challenges from the client application, and output authorization codes to stdout.

**Primary recommendation:** Implement two new CLI subcommands (`register-client`, `authorize`) that follow existing patterns: fail-fast HTTP wrapper, base64url encoding for keys, and raw JSON output via print_output().

## Standard Stack

The established libraries and tools for this implementation:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| pynacl | >=1.5.0 | Ed25519 key generation and signing | Matches backend @noble/ed25519 |
| python-dotenv | >=1.0.0 | Configuration management | Already in use by agent-demo.py |
| urllib.request | stdlib | HTTP requests | Already in use by agent-demo.py |
| argparse | stdlib | CLI argument parsing | Already in use by agent-demo.py |

### No New Dependencies Required

All functionality can be achieved with existing dependencies plus standard library modules already imported in agent-demo.py:
- `json`, `os`, `uuid` - JSON handling, env file access, UUID generation
- `urllib.request`, `urllib.error`, `urllib.parse` - HTTP operations

## Architecture Patterns

### Recommended CLI Structure

Add two new subcommands to the existing argparse structure:

```
python agent_demo.py register-client --name "My Client" --redirect-uri "https://localhost:3000/callback" [--generate | --private-key <key> --public-key <key>]
python agent_demo.py authorize --client-id <uuid> --redirect-uri <uri> --code-challenge <challenge> [--scope <scopes>]
```

### Pattern 1: Client Key Storage (Per CONTEXT.md)

**What:** Store client keys using server-generated client ID as namespace in .env

**When to use:** When registering or loading OAuth client keys

**Implementation:**
```python
# After successful client registration, extract client_id from response
CLIENT_<client-id>_PUBLIC_KEY=<base64url-encoded key>
CLIENT_<client-id>_PRIVATE_KEY=<base64url-encoded key>
CLIENT_<client-id>_ID=<uuid>
```

**Key namespaces (ENV_KEYS extension):**
```python
CLIENT_ENV_KEYS = {
    "client_{client_id}_public_key": "CLIENT_{client_id}_PUBLIC_KEY",
    "client_{client_id}_private_key": "CLIENT_{client_id}_PRIVATE_KEY",
    "client_{client_id}_id": "CLIENT_{client_id}_ID",
}
```

### Pattern 2: Three Key Provision Options

**What:** Support three ways to provide client keys per CONTEXT.md

**Option 1: --generate** - Generate new keypair
```python
private_b64url, public_b64url = generate_keypair()
# Save to .env under client ID namespace after registration
```

**Option 2: No flags** - Read existing keys from .env
```python
# Read CLIENT_<client-id>_PUBLIC_KEY and CLIENT_<client-id>_PRIVATE_KEY
# Validate keys match before use
```

**Option 3: Explicit keys** - User provides keys
```python
# Validate keys match using validate_keys_match()
# Save to .env under client ID namespace
```

### Pattern 3: Authorization with PKCE Input

**What:** Accept PKCE code challenge from client application (not generated by script)

**When to use:** The authorize subcommand receives a pre-generated code challenge from the client app

**Request body format (per backend oauth.ts):**
```python
{
    "client_id": client_id,
    "redirect_uri": redirect_uri,
    "scope": scope or "id name description subscription",
    "state": state,  # optional
    "code_challenge": code_challenge,  # required from client app
    "code_challenge_method": "S256",  # hardcoded
}
```

### Authentication Options for Authorization

The `/v1/oauth/authorize` endpoint accepts two authentication methods:

1. **Bearer token (session):** Use existing `session_id` from .env
   ```python
   headers = {"Authorization": f"Bearer {session_id}"}
   ```

2. **DPoP proof:** Use agent's private key to create DPoP proof
   ```python
   dpop_proof = create_dpop_proof(private_key, "POST", authorize_url)
   headers = {"DPoP": dpop_proof}
   # Also requires agent_id in request body
   ```

The CLI should prioritize session-based auth (like existing commands), falling back to DPoP if session is unavailable but keys are present.

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Key storage format | Custom key-value format | .env with CLIENT_<id>_* namespace | Matches CONTEXT.md spec, leverages python-dotenv |
| PKCE generation | Build PKCE logic | Client app provides code_challenge | Per CONTEXT.md - script accepts challenge, doesn't generate |
| Authorization code handling | Auto-redirect or file save | print_output() to stdout | Per CONTEXT.md - user manually copies code |

## Common Pitfalls

### Pitfall 1: Client ID Namespace Mismatch
**What goes wrong:** Keys saved under wrong namespace (e.g., client name instead of client ID)
**Why it happens:** Client ID is server-generated UUID - only known after registration
**How to avoid:** 
1. First call register-client API to get client_id
2. Then save keys under CLIENT_<client-id>_* namespace
3. For "reuse existing keys" option, require --client-id flag to read from correct namespace
**Warning signs:** "Client not found" errors when trying to authorize

### Pitfall 2: PKCE Method Mismatch
**What goes wrong:** Backend rejects authorization request because code_challenge_method is not S256
**Why it happens:** Hardcoding wrong method or accepting client-provided method
**How to avoid:** Always send `"code_challenge_method": "S256"` in request body (CONTEXT.md specifies this)
**Warning signs:** "invalid_request" error with "Only S256 code_challenge_method is supported"

### Pitfall 3: Missing Authentication
**What goes wrong:** 401 Unauthorized when calling /v1/oauth/authorize
**Why it happens:** Neither session_id nor DPoP proof provided
**How to avoid:** 
- Prioritize session_id from config
- If no session, check for private_key and construct DPoP proof
- If neither available, print helpful error message
**Warning signs:** "Agent authentication required" error

### Pitfall 4: Redirect URI Validation
**What goes wrong:** "invalid_redirect_uri" error from backend
**Why it happens:** Redirect URI not registered for the client
**How to avoid:** Require --redirect-uri and pass to registration, use same URI for authorization
**Warning signs:** Backend returns error about redirect URI

### Pitfall 5: Public Key Format
**What goes wrong:** Backend rejects public key during client registration
**Why it happens:** Key not in base64url format or invalid Ed25519 key
**How to avoid:** Use existing base64url_encode() on VerifyKey bytes, validate with validate_keys_match()
**Warning signs:** "Invalid Ed25519 public key format" error

## Code Examples

### API Call 1: Register OAuth Client

**Source:** Backend routes/clients.ts

```python
def register_oauth_client(
    backend_url: str,
    session_id: str,
    name: str,
    redirect_uris: list[str],
    public_key: str,
    scope: Optional[str] = None
) -> dict:
    """
    Register an OAuth client for the authenticated agent.
    
    Args:
        backend_url: Base URL of the backend API
        session_id: Agent session token
        name: Client name
        redirect_uris: List of allowed redirect URIs
        public_key: Base64url-encoded Ed25519 public key
        scope: Optional space-separated scopes
    
    Returns:
        Dict with keys:
        - success: bool
        - client: {id, name, redirect_uris, scope}
        - message: str
    """
    url = f"{backend_url}/v1/clients/register/agent"
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {session_id}"
    }
    body = {
        "name": name,
        "redirect_uris": redirect_uris,
        "public_key": public_key,
    }
    if scope:
        body["scope"] = scope
    
    data = json.dumps(body).encode("utf-8")
    req = urllib.request.Request(url, data=data, headers=headers, method="POST")
    
    try:
        with urllib.request.urlopen(req) as resp:
            return json.loads(resp.read().decode("utf-8"))
    except urllib.error.HTTPError as e:
        error_body = e.read().decode("utf-8")
        print(error_body, file=sys.stderr)
        sys.exit(1)
```

### API Call 2: Initiate OAuth Authorization

**Source:** Backend routes/oauth.ts

```python
def initiate_oauth_authorization(
    backend_url: str,
    session_id: str,
    client_id: str,
    redirect_uri: str,
    code_challenge: str,
    scope: Optional[str] = None,
    state: Optional[str] = None,
    private_key: Optional[SigningKey] = None,
    agent_id: Optional[str] = None
) -> dict:
    """
    Initiate OAuth authorization flow.
    
    Args:
        backend_url: Base URL of the backend API
        session_id: Agent session token (Bearer auth)
        client_id: OAuth client ID (UUID)
        redirect_uri: Redirect URI registered with client
        code_challenge: PKCE code challenge from client app
        scope: Optional space-separated scopes
        state: Optional state parameter
        private_key: Ed25519 private key (for DPoP auth)
        agent_id: Agent ID (required for DPoP auth)
    
    Returns:
        Dict with keys:
        - authorization_code: str
        - redirect_uri: str
        - state: str (if provided)
        - scope: str
    """
    url = f"{backend_url}/v1/oauth/authorize"
    
    # Build headers - prefer Bearer auth
    headers = {"Content-Type": "application/json"}
    
    if session_id:
        headers["Authorization"] = f"Bearer {session_id}"
    elif private_key and agent_id:
        # Use DPoP proof
        dpop_proof = create_dpop_proof(private_key, "POST", url)
        headers["DPoP"] = dpop_proof
    else:
        print("Error: Authentication required (session_id or private_key + agent_id)", file=sys.stderr)
        sys.exit(1)
    
    body = {
        "client_id": client_id,
        "redirect_uri": redirect_uri,
        "code_challenge": code_challenge,
        "code_challenge_method": "S256",  # hardcoded per CONTEXT.md
    }
    if scope:
        body["scope"] = scope
    if state:
        body["state"] = state
    if private_key and agent_id:
        body["agent_id"] = agent_id
    
    data = json.dumps(body).encode("utf-8")
    req = urllib.request.Request(url, data=data, headers=headers, method="POST")
    
    try:
        with urllib.request.urlopen(req) as resp:
            return json.loads(resp.read().decode("utf-8"))
    except urllib.error.HTTPError as e:
        error_body = e.read().decode("utf-8")
        print(error_body, file=sys.stderr)
        sys.exit(1)
```

### CLI Command: register-client

```python
def cmd_register_client(args) -> int:
    """Register a new OAuth client for the authenticated agent."""
    config = load_config()
    
    # Validate required config
    required = ["backend_url", "session_id"]
    missing = [k for k in required if not config.get(k)]
    if missing:
        print(f"Error: Missing required config: {', '.join(missing)}", file=sys.stderr)
        return 1
    
    # Handle key provision options
    private_key_b64url = None
    public_key_b64url = None
    
    if args.generate:
        # Option 1: Generate new keypair
        private_key_b64url, public_key_b64url = generate_keypair()
    elif args.private_key and args.public_key:
        # Option 3: User provides keys
        private_key_b64url = args.private_key
        public_key_b64url = args.public_key
        is_valid, msg = validate_keys_match(private_key_b64url, public_key_b64url)
        if not is_valid:
            print(f"Error: Invalid keys - {msg}", file=sys.stderr)
            return 1
    else:
        # Option 2: Must provide client_id to read existing keys
        if not args.client_id:
            print("Error: Either --generate or --private-key/--public-key required", file=sys.stderr)
            return 1
        # Keys will be loaded after registration using client_id
    
    # Call registration API
    result = register_oauth_client(
        backend_url=config["backend_url"],
        session_id=config["session_id"],
        name=args.name,
        redirect_uris=[args.redirect_uri],
        public_key=public_key_b64url,  # May be None for option 2
    )
    
    if not result.get("success"):
        print(f"Error: {result.get('error', 'Registration failed')}", file=sys.stderr)
        return 1
    
    # Get client_id from response
    client_id = result["client"]["id"]
    
    # Save keys under client namespace
    if private_key_b64url and public_key_b64url:
        client_config = {
            f"client_{client_id}_private_key": private_key_b64url,
            f"client_{client_id}_public_key": public_key_b64url,
            f"client_{client_id}_id": client_id,
        }
        save_client_config(client_config)
    
    print_output(json.dumps(result))
    return 0
```

### CLI Command: authorize

```python
def cmd_authorize(args) -> int:
    """Initiate OAuth authorization for a client."""
    config = load_config()
    
    # Validate required config
    if not config.get("backend_url"):
        print("Error: backend_url not configured", file=sys.stderr)
        return 1
    
    # Determine auth method
    session_id = config.get("session_id")
    private_key = None
    
    if not session_id and config.get("private_key"):
        # Fall back to DPoP
        private_key = load_private_key(config["private_key"])
    
    if not session_id and not private_key:
        print("Error: Authentication required (session_id or private_key needed)", file=sys.stderr)
        return 1
    
    # Build scope
    scope = args.scope or "id name description subscription"
    
    # Call authorization API
    result = initiate_oauth_authorization(
        backend_url=config["backend_url"],
        session_id=session_id,
        client_id=args.client_id,
        redirect_uri=args.redirect_uri,
        code_challenge=args.code_challenge,
        scope=scope,
        state=args.state,
        private_key=private_key,
        agent_id=config.get("agent_id") if private_key else None,
    )
    
    # Output authorization code
    print_output(json.dumps(result))
    return 0
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Agent-only registration | OAuth client registration with key management | Phase 35 | New capability for agents to act as OAuth clients |
| Manual auth code copy | Authorization endpoint returns code directly | Phase 35 | Enables programmatic OAuth flows |

**Current OAuth flow implementation:**
- Client registration: `POST /v1/clients/register/:owner_type`
- Authorization: `POST /v1/oauth/authorize` with PKCE
- Token exchange: `POST /v1/oauth/token` (Phase 36+)

## Open Questions

1. **Client listing:** Should the CLI include a `list-clients` subcommand?
   - Backend supports `GET /v1/clients/list/agent`
   - Not in current requirements (AOAUTH-01, AOAUTH-02 only)
   - Recommendation: Defer to future phase if needed

2. **Multiple redirect URIs:** Should register-client accept multiple --redirect-uri flags?
   - Backend accepts array of redirect_uris
   - Could add `action='append'` to argparse
   - Recommendation: Start with single URI (--redirect-uri), extend if needed

3. **Client key rotation:** Should the CLI support rotating client keys?
   - Backend supports `PUT /v1/clients/:client_id/key`
   - Not in current requirements
   - Recommendation: Defer to future phase

## Sources

### Primary (HIGH confidence)
- `/backend/src/routes/clients.ts` - OAuth client registration endpoints
- `/backend/src/routes/oauth.ts` - OAuth authorization endpoints
- `/backend/src/services/oauth-client.ts` - Client service implementation
- `demo/agent/agent-demo.py` - Existing CLI patterns

### Secondary (MEDIUM confidence)
- `/frontend/src/api/client.ts` - Frontend OAuth client registration patterns

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Existing dependencies confirmed, no new packages needed
- Architecture: HIGH - Based on existing agent-demo.py patterns, CONTEXT.md specifications
- Pitfalls: HIGH - Derived from backend validation logic in oauth-client.ts and oauth.ts

**Research date:** 2026-02-22
**Valid until:** 90 days (API structure stable, requirements locked in CONTEXT.md)
