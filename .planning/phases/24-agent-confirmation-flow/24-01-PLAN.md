---
phase: 24-agent-confirmation-flow
plan: 01
type: execute
wave: 1
depends_on: [23-02]
files_modified:
  - backend/src/routes/agents.ts
  - backend/src/services/ownership.ts
  - backend/src/services/overseer.ts
autonomous: true

must_haves:
  truths:
    - Agent must POST to claim completion endpoint with valid DPoP or session
    - Backend verifies agent matches challenge's agent_id
    - Backend checks agent is not already claimed by real overseer
    - Challenge updated to awaiting-payment status with Paddle data
  artifacts:
    - path: backend/src/routes/agents.ts
      provides: Updated claim completion endpoint with isShadow check
      min_lines: 80
    - path: backend/src/services/ownership.ts
      provides: Shadow overseer lookup/creation logic
      min_lines: 30
  key_links:
    - from: POST /v1/agents/claim/complete/:challengeId
      to: CHALLENGES KV
      via: isShadow flag check
      pattern: if (claimData.isShadow) { ... }
    - from: Agent confirmation
      to: CHALLENGES KV update
      via: status: 'awaiting-payment'
      pattern: Paddle checkout data storage
---

<objective>
Implement agent confirmation step for shadow claims before payment processing.

Purpose: Add security gate so agents control who oversees them
Output: Agent confirmation flow that prepares challenge for payment
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@docs/v1/requirements/agent/shadow-claim.md

@backend/src/routes/agents.ts
@backend/src/services/ownership.ts
@backend/src/services/overseer.ts
@backend/src/db/schema/overseers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update claim completion endpoint to check isShadow flag</name>
  <files>backend/src/routes/agents.ts</files>
  <action>
    Modify POST /v1/agents/claim/complete/:challengeId to handle shadow claims:
    
    1. After retrieving claim data from KV, check if claimData.isShadow === true
    2. If isShadow is true, branch to shadow claim confirmation logic
    3. If isShadow is false/undefined, proceed with standard claim completion
    
    Shadow claim confirmation logic:
    1. Verify agent authentication (DPoP or session) - already done earlier in endpoint
    2. Verify authenticatedAgentId === claimData.agent_id
    3. Verify agent is not already claimed by real overseer:
       - Query oversights table for active oversight
       - If exists, check if overseer is shadow using isShadowOverseer()
       - If real overseer exists, reject with 409 error
    4. Check if shadow overseer already exists:
       - Query overseers table by id = claimData.overseer_id
       - If exists, capture email and paddle_customer_id for reuse
    5. If shadow overseer doesn't exist:
       - Generate shadow overseer email: shadow-{agent_id_prefix}@internal.local
       - These values will be used when creating overseer after payment
    6. Update challenge in KV:
       - Set status to 'awaiting-payment'
       - Add paddle_price_id for SHADOW tier
       - Add shadow_overseer_email
       - Add any other data needed for Paddle checkout
    7. Return success response:
       {
         success: true,
         message: 'Shadow claim confirmed. Awaiting payment.',
         status: 'awaiting-payment',
         shadow_overseer_id: claimData.overseer_id
       }
    
    Security checks:
    - Agent must be authenticated
    - Agent must match challenge's agent_id
    - Agent cannot be claimed by real overseer
    - Challenge must not be expired
  </action>
  <verify>
    - Endpoint handles both standard and shadow claims correctly
    - isShadow flag properly branches logic
    - All security checks implemented
    - Response includes awaiting-payment status
  </verify>
  <done>
    Claim completion endpoint branches to shadow confirmation when isShadow flag is present
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement shadow overseer existence check</name>
  <files>backend/src/services/ownership.ts</files>
  <action>
    Add or update function to check if shadow overseer exists:
    
    1. Create getShadowOverseerById(db, overseerId) function:
       - Query overseers table by id
       - Return overseer record or null
       
    2. Update generateShadowOverseerEmail(agentId) function:
       - Format: shadow-{agent_id.substring(0, 8)}@internal.local
       - Make reusable across services
       
    3. Ensure these functions can be imported from ownership.ts
    
    The goal is to:
    - Check if shadow overseer already exists (for renewals)
    - Generate consistent email format for new shadow overseers
    - Reuse existing paddle_customer_id if overseer exists
  </action>
  <verify>
    - Functions compile without errors
    - getShadowOverseerById returns correct data
    - Email generation is consistent
  </verify>
  <done>
    Helper functions for shadow overseer lookup and email generation implemented
  </done>
</task>

<task type="auto">
  <name>Task 3: Add real overseer validation</name>
  <files>backend/src/routes/agents.ts</files>
  <action>
    Implement validation to prevent shadow claim when real overseer exists:
    
    1. Before confirming shadow claim, check for active oversight:
       ```typescript
       const activeOversight = await getActiveOversight(c.env.DB, agentId);
       if (activeOversight) {
         const isShadow = await isShadowOverseer(activeOversight.overseer_id, c.env);
         if (!isShadow) {
           return c.json({ 
             success: false, 
             error: 'Agent is already claimed by a real overseer' 
           }, 409);
         }
       }
       ```
    
    2. This ensures:
       - Shadow claim can proceed if only shadow overseer exists (renewal)
       - Shadow claim is rejected if real overseer exists
       - Unclaimed agents can be shadow claimed
    
    3. Add appropriate error messages for each case
    
    4. Delete challenge if validation fails (cleanup)
  </action>
  <verify>
    - Real overseer check implemented
    - Shadow overseer renewal allowed
    - Unclaimed agents allowed
    - Correct error responses
  </verify>
  <done>
    Shadow claim rejected when real overseer exists, allowed for renewals
  </done>
</task>

<task type="auto">
  <name>Task 4: Store Paddle checkout data in challenge</name>
  <files>backend/src/routes/agents.ts</files>
  <action>
    Update challenge with payment preparation data:
    
    1. Get Paddle price ID for SHADOW tier from environment:
       - env.PADDLE_PRICE_ID_SHADOW
    
    2. Update challenge data structure:
       ```typescript
       const updatedChallenge = {
         ...claimData,
         status: 'awaiting-payment',
         paddle_price_id: env.PADDLE_PRICE_ID_SHADOW,
         shadow_overseer_email: existingOverseer?.email || generateShadowOverseerEmail(agentId),
         shadow_overseer_exists: !!existingOverseer,
         updated_at: new Date().toISOString()
       };
       ```
    
    3. Store updated challenge in KV (overwrite existing)
    4. Keep same TTL (don't reset expiration)
    
    This data will be used by:
    - Frontend to initiate Paddle checkout
    - Webhook to link payment to challenge
  </action>
  <verify>
    - Challenge updated with awaiting-payment status
    - Paddle price ID included
    - Shadow overseer email included
    - TTL preserved
  </verify>
  <done>
    Challenge updated with all data needed for Paddle checkout
  </done>
</task>

</tasks>

<verification>
1. Agent must authenticate to confirm shadow claim
2. Backend verifies agent matches challenge
3. Backend prevents shadow claim when real overseer exists
4. Challenge updated to awaiting-payment status
5. Paddle checkout data stored in challenge
6. All security checks pass tests
</verification>

<success_criteria>
- Agent POST to claim completion triggers shadow confirmation when isShadow flag present
- All security validations implemented (identity, existing overseer, expiration)
- Challenge updated to awaiting-payment status with Paddle data
- Response confirms awaiting-payment state
- Backend compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/24-agent-confirmation-flow/24-01-SUMMARY.md`
</output>
