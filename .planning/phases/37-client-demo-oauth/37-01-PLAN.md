---
phase: 37-client-demo-oauth
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [demo/client/client-demo.py]
autonomous: true

must_haves:
  truths:
    - "User can refresh access tokens using refresh token grant with --agent-id flag"
    - "Refreshed tokens are auto-saved to .env overwriting previous values"
    - "User can query OpenID discovery endpoint and see full JSON output"
    - "DPoP proof helper correctly computes ath claim from access token"
  artifacts:
    - path: "demo/client/client-demo.py"
      provides: "hash_access_token helper, create_dpop_proof helper, cmd_refresh handler, cmd_discover handler, CLI subcommands"
      contains: "def hash_access_token"
    - path: "demo/client/client-demo.py"
      provides: "create_dpop_proof helper for DPoP JWT generation"
      contains: "def create_dpop_proof"
    - path: "demo/client/client-demo.py"
      provides: "refresh subcommand handler"
      contains: "def cmd_refresh"
    - path: "demo/client/client-demo.py"
      provides: "discover subcommand handler"
      contains: "def cmd_discover"
  key_links:
    - from: "cmd_refresh"
      to: "create_client_assertion"
      via: "private_key_jwt auth for refresh grant"
      pattern: "create_client_assertion.*token_endpoint"
    - from: "cmd_refresh"
      to: ".env"
      via: "set_key to save refreshed tokens"
      pattern: "set_key.*AGENT_.*_ACCESS_TOKEN"
    - from: "create_dpop_proof"
      to: "hash_access_token"
      via: "ath claim computation"
      pattern: "hash_access_token.*access_token"
    - from: "cmd_discover"
      to: "make_request"
      via: "GET to well-known endpoint"
      pattern: "well-known/openid-configuration"
---

<objective>
Add helper functions (hash_access_token, create_dpop_proof), refresh subcommand, and discover subcommand to client-demo.py.

Purpose: Provides foundational DPoP proof generation needed by Plan 02's userinfo command, plus the two simplest new subcommands (refresh uses existing private_key_jwt pattern, discover is a simple GET).
Output: client-demo.py with 2 new helper functions, 2 new command handlers, 2 new argparse subcommands, 2 new command_handlers entries.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-client-demo-oauth/37-CONTEXT.md
@.planning/phases/37-client-demo-oauth/37-RESEARCH.md
@demo/client/client-demo.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add helper functions (hash_access_token, create_dpop_proof)</name>
  <files>demo/client/client-demo.py</files>
  <action>
Add two new helper functions in a new section immediately AFTER the "Client Assertion JWT Construction" section (after `create_client_assertion`) and BEFORE the "HTTP Callback Server" section. Use section header:

```
# =============================================================================
# DPoP Proof Construction
# =============================================================================
```

**Function 1: `hash_access_token(access_token: str) -> str`**
- Computes SHA-256 hash of the access token string (encoded as UTF-8 bytes)
- Returns base64url-encoded hash (no padding) — this is the `ath` claim value
- Implementation: `base64url_encode(hashlib.sha256(access_token.encode('utf-8')).digest())`
- hashlib is already imported at line 24

**Function 2: `create_dpop_proof(private_key: SigningKey, method: str, uri: str, access_token: str = None) -> str`**
- Creates a DPoP proof JWT per the project's DPoP spec
- Header: `{"typ": "dpop+jwt", "alg": "EdDSA"}` — NO `jwk` field in header
- Payload claims:
  - `jti`: `str(uuid.uuid4())`
  - `htm`: the `method` parameter (e.g., "GET")
  - `htu`: the `uri` parameter (e.g., "https://example.com/v1/oauth/userinfo")
  - `iat`: `int(time.time())`
  - If `access_token` is not None, add `ath`: `hash_access_token(access_token)`
- Build signing input as `base64url_encode_json(header) + "." + base64url_encode_json(payload)`
- Sign with `private_key.sign(signing_input.encode('utf-8'))`, extract `.signature`
- Return complete JWT: `header.payload.signature` (all base64url encoded)
- This follows the exact same JWT construction pattern as `create_client_assertion` above it
  </action>
  <verify>
Run `python -c "import client_demo_check; print('OK')"` is not feasible since the file uses `.env`. Instead verify by:

```bash
cd demo/client && python -c "
import importlib.util, sys
spec = importlib.util.spec_from_file_location('client_demo', 'client-demo.py')
mod = importlib.util.module_from_spec(spec)
# Don't execute main, just check functions exist
import ast
with open('client-demo.py') as f:
    tree = ast.parse(f.read())
funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]
assert 'hash_access_token' in funcs, 'hash_access_token not found'
assert 'create_dpop_proof' in funcs, 'create_dpop_proof not found'
print('All helper functions present')
"
```

Also verify no syntax errors: `cd demo/client && python -c "import ast; ast.parse(open('client-demo.py').read()); print('Syntax OK')"`
  </verify>
  <done>hash_access_token and create_dpop_proof functions exist in client-demo.py with correct signatures, no syntax errors</done>
</task>

<task type="auto">
  <name>Task 2: Add refresh and discover subcommands</name>
  <files>demo/client/client-demo.py</files>
  <action>
Add two new command handlers and their CLI definitions.

**Command Handler: `cmd_refresh(args) -> int`**
Add after `cmd_config` function, before the CLI Interface section. Implementation:

1. Load config via `load_config()`. Validate `backend_url`, `client_id`, `private_key` are set (fail-fast with print to stderr + return 1).
2. Build token endpoint: `f"{config['backend_url']}/v1/oauth/token"`
3. Load private key: `load_private_key(config['private_key'])`
4. Create client assertion: `create_client_assertion(private_key, config['client_id'], token_endpoint)` — aud is the token endpoint URL
5. Load refresh token from env: `os.getenv(f"AGENT_{args.agent_id}_REFRESH_TOKEN")`. If None, print error to stderr, return 1.
6. Build request body (form-urlencoded):
   - `grant_type`: `refresh_token`
   - `refresh_token`: the loaded refresh token
   - `client_id`: `config['client_id']`
   - `client_assertion`: the assertion JWT
   - `client_assertion_type`: `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`
7. `body_bytes = urllib.parse.urlencode(body_fields).encode('utf-8')`
8. Make request: `make_request(token_endpoint, {"Content-Type": "application/x-www-form-urlencoded"}, data=body_bytes)`
9. `print_output(response_string)` — print full JSON to stdout
10. Parse response, extract `access_token` and `refresh_token` from JSON
11. Save BOTH tokens to .env using `set_key(ENV_FILE, f"AGENT_{args.agent_id}_ACCESS_TOKEN", access_token)` and same for refresh token — silent overwrite, no logging of rotation
12. Return 0. Wrap entire body in try/except Exception, print to stderr, return 1.

**Command Handler: `cmd_discover(args) -> int`**
Add after `cmd_refresh`. Implementation:

1. Load config via `load_config()`. Validate `backend_url` is set.
2. Build well-known URL: `f"{config['backend_url']}/v1/oauth/.well-known/openid-configuration"`
3. Make request: `make_request(well_known_url, {})` — simple GET, no auth
4. `print_output(response_string)` — print full JSON
5. Return 0. Wrap in try/except.

**CLI Subcommand Definitions** — add in the `main()` function, after the `config` subparser block and before `args = parser.parse_args()`:

```python
# refresh command
parser_refresh = subparsers.add_parser(
    "refresh",
    help="Refresh access token using refresh token grant",
)
parser_refresh.add_argument(
    "--agent-id", required=True, help="Agent ID for token lookup/storage"
)

# discover command
subparsers.add_parser(
    "discover",
    help="Query OpenID Connect discovery endpoint",
)
```

**Command Handlers Dict** — add two entries to the `command_handlers` dict in `main()`:
```python
"refresh": cmd_refresh,
"discover": cmd_discover,
```
  </action>
  <verify>
Verify syntax and all commands registered:

```bash
cd demo/client && python -c "
import ast
with open('client-demo.py') as f:
    tree = ast.parse(f.read())
funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]
assert 'cmd_refresh' in funcs, 'cmd_refresh missing'
assert 'cmd_discover' in funcs, 'cmd_discover missing'
print('All command handlers present')
"
```

Verify CLI help shows new commands:
```bash
cd demo/client && python client-demo.py --help 2>&1 | grep -E '(refresh|discover)'
```

Verify no syntax errors:
```bash
cd demo/client && python -c "import ast; ast.parse(open('client-demo.py').read()); print('Syntax OK')"
```
  </verify>
  <done>cmd_refresh and cmd_discover handlers exist, are registered in command_handlers dict, have argparse subcommands defined, CLI help shows both commands, no syntax errors</done>
</task>

</tasks>

<verification>
1. `cd demo/client && python -c "import ast; ast.parse(open('client-demo.py').read()); print('Syntax OK')"` — no syntax errors
2. `cd demo/client && python client-demo.py --help` — shows refresh, discover in command list
3. `cd demo/client && python client-demo.py refresh --help` — shows --agent-id flag
4. `cd demo/client && python client-demo.py discover --help` — shows no required flags
5. Verify functions exist: hash_access_token, create_dpop_proof, cmd_refresh, cmd_discover
</verification>

<success_criteria>
- client-demo.py has hash_access_token and create_dpop_proof helper functions
- client-demo.py has cmd_refresh handler that sends refresh_token grant with private_key_jwt auth and auto-saves both tokens to .env
- client-demo.py has cmd_discover handler that GETs well-known endpoint and prints JSON
- Both subcommands registered in argparse and command_handlers
- File has no syntax errors
- Requirements covered: CTOKEN-02 (refresh), COAUTH-03 (discover)
</success_criteria>

<output>
After completion, create `.planning/phases/37-client-demo-oauth/37-01-SUMMARY.md`
</output>
