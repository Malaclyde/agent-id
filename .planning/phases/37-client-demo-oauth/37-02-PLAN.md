---
phase: 37-client-demo-oauth
plan: 02
type: execute
wave: 2
depends_on: ["37-01"]
files_modified: [demo/client/client-demo.py]
autonomous: true

must_haves:
  truths:
    - "User can query userinfo with DPoP-bound access token using --agent-id flag"
    - "User can revoke access or refresh tokens with --agent-id and --access/--refresh flags"
    - "User can introspect tokens for status and metadata with --agent-id and --access/--refresh flags"
  artifacts:
    - path: "demo/client/client-demo.py"
      provides: "userinfo command handler with DPoP proof"
      contains: "def cmd_userinfo"
    - path: "demo/client/client-demo.py"
      provides: "revoke command handler with private_key_jwt"
      contains: "def cmd_revoke"
    - path: "demo/client/client-demo.py"
      provides: "introspect command handler with private_key_jwt"
      contains: "def cmd_introspect"
  key_links:
    - from: "cmd_userinfo"
      to: "create_dpop_proof"
      via: "DPoP proof JWT with ath claim for GET userinfo"
      pattern: "create_dpop_proof.*GET.*userinfo"
    - from: "cmd_userinfo"
      to: "make_request"
      via: "GET with Authorization: DPoP + DPoP header"
      pattern: "DPoP.*access_token"
    - from: "cmd_revoke"
      to: "create_client_assertion"
      via: "private_key_jwt auth with revoke endpoint as aud"
      pattern: "create_client_assertion.*revoke"
    - from: "cmd_introspect"
      to: "create_client_assertion"
      via: "private_key_jwt auth with introspect endpoint as aud"
      pattern: "create_client_assertion.*introspect"
    - from: "cmd_revoke"
      to: "args"
      via: "mutually exclusive --access/--refresh flags"
      pattern: "add_mutually_exclusive_group"
    - from: "cmd_introspect"
      to: "args"
      via: "mutually exclusive --access/--refresh flags"
      pattern: "add_mutually_exclusive_group"
---

<objective>
Add userinfo, revoke, and introspect subcommands to client-demo.py.

Purpose: Completes Phase 37 by adding the three remaining OAuth operation subcommands. Userinfo uses DPoP-bound access token (depends on create_dpop_proof from Plan 01). Revoke and introspect both use private_key_jwt auth with mutually exclusive --access/--refresh token type flags.
Output: client-demo.py with 3 new command handlers, 3 new argparse subcommands with correct flag patterns, 3 new command_handlers entries. All Phase 37 requirements satisfied.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/37-client-demo-oauth/37-CONTEXT.md
@.planning/phases/37-client-demo-oauth/37-RESEARCH.md
@.planning/phases/37-client-demo-oauth/37-01-SUMMARY.md
@demo/client/client-demo.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add userinfo subcommand with DPoP-bound access token</name>
  <files>demo/client/client-demo.py</files>
  <action>
Add `cmd_userinfo(args) -> int` command handler after the existing command handlers (after cmd_discover, before the CLI Interface section).

**Implementation:**

1. Load config via `load_config()`. Validate `backend_url`, `client_id`, `private_key` are set (fail-fast: print error to stderr, return 1).
2. Build userinfo URL: `f"{config['backend_url']}/v1/oauth/userinfo"`
3. Load access token from env: `os.getenv(f"AGENT_{args.agent_id}_ACCESS_TOKEN")`. If None, print error to stderr, return 1.
4. Load private key: `load_private_key(config['private_key'])`
5. Create DPoP proof using `create_dpop_proof(private_key, "GET", userinfo_url, access_token=access_token)` — this was added in Plan 01. The proof includes:
   - Header: `{"typ": "dpop+jwt", "alg": "EdDSA"}` — NO jwk
   - Payload: jti, htm="GET", htu=userinfo_url, iat, ath=hash of access token
6. Build request headers:
   - `"Authorization": f"DPoP {access_token}"`
   - `"DPoP": dpop_proof`
7. Make request: `make_request(userinfo_url, headers, method="GET")` — explicit GET method
8. `print_output(response_string)`
9. Return 0. Wrap in try/except Exception, print to stderr, return 1.

**CLI Subcommand** — add in `main()` after existing subparser blocks, before `args = parser.parse_args()`:

```python
# userinfo command
parser_userinfo = subparsers.add_parser(
    "userinfo",
    help="Query userinfo endpoint with DPoP-bound access token",
)
parser_userinfo.add_argument(
    "--agent-id", required=True, help="Agent ID for token lookup"
)
```

**Command Handler Entry:**
```python
"userinfo": cmd_userinfo,
```
  </action>
  <verify>
```bash
cd demo/client && python -c "
import ast
with open('client-demo.py') as f:
    tree = ast.parse(f.read())
funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]
assert 'cmd_userinfo' in funcs, 'cmd_userinfo missing'
print('cmd_userinfo present')
"
```

```bash
cd demo/client && python client-demo.py userinfo --help
```
  </verify>
  <done>cmd_userinfo exists, uses create_dpop_proof for DPoP JWT with ath claim, sends GET with Authorization: DPoP and DPoP headers, prints raw JSON output, registered in CLI</done>
</task>

<task type="auto">
  <name>Task 2: Add revoke and introspect subcommands with private_key_jwt auth</name>
  <files>demo/client/client-demo.py</files>
  <action>
Add `cmd_revoke(args) -> int` and `cmd_introspect(args) -> int` command handlers after cmd_userinfo.

**Command Handler: `cmd_revoke(args) -> int`**

1. Load config via `load_config()`. Validate `backend_url`, `client_id`, `private_key` are set.
2. Build revoke endpoint: `f"{config['backend_url']}/v1/oauth/revoke"`
3. Load private key: `load_private_key(config['private_key'])`
4. Create client assertion: `create_client_assertion(private_key, config['client_id'], revoke_endpoint)` — CRITICAL: aud must be the revoke endpoint URL (NOT the token endpoint)
5. Determine token type and load token from .env:
   - If `args.access` is True: `token_type_hint = "access_token"`, load `os.getenv(f"AGENT_{args.agent_id}_ACCESS_TOKEN")`
   - If `args.refresh` is True: `token_type_hint = "refresh_token"`, load `os.getenv(f"AGENT_{args.agent_id}_REFRESH_TOKEN")`
   - If token is None, print error to stderr, return 1
6. Build request body (form-urlencoded):
   - `token`: the loaded token value
   - `token_type_hint`: `"access_token"` or `"refresh_token"`
   - `client_id`: `config['client_id']`
   - `client_assertion`: the assertion JWT
   - `client_assertion_type`: `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`
7. `body_bytes = urllib.parse.urlencode(body_fields).encode('utf-8')`
8. Make request: `make_request(revoke_endpoint, {"Content-Type": "application/x-www-form-urlencoded"}, data=body_bytes)`
9. `print_output(response_string)`
10. Return 0. No post-revocation cleanup (per CONTEXT.md). Wrap in try/except.

**Command Handler: `cmd_introspect(args) -> int`**

Nearly identical to cmd_revoke, with these differences:
1. Endpoint: `f"{config['backend_url']}/v1/oauth/introspect"` — aud is the introspect endpoint
2. Request body fields:
   - `token`: the loaded token value
   - `token_type_hint`: `"access_token"` or `"refresh_token"`
   - `client_id`: `config['client_id']`
   - `client_assertion`: the assertion JWT
   - `client_assertion_type`: `urn:ietf:params:oauth:client-assertion-type:jwt-bearer`
3. `print_output(response_string)` — raw JSON output

**CLI Subcommand Definitions** — add in `main()`, after userinfo subparser, before `args = parser.parse_args()`:

```python
# revoke command
parser_revoke = subparsers.add_parser(
    "revoke",
    help="Revoke an access or refresh token",
)
parser_revoke.add_argument(
    "--agent-id", required=True, help="Agent ID for token lookup"
)
revoke_token_type = parser_revoke.add_mutually_exclusive_group(required=True)
revoke_token_type.add_argument(
    "--access", action="store_true", help="Revoke access token"
)
revoke_token_type.add_argument(
    "--refresh", action="store_true", help="Revoke refresh token"
)

# introspect command
parser_introspect = subparsers.add_parser(
    "introspect",
    help="Introspect a token for status and metadata",
)
parser_introspect.add_argument(
    "--agent-id", required=True, help="Agent ID for token lookup"
)
introspect_token_type = parser_introspect.add_mutually_exclusive_group(required=True)
introspect_token_type.add_argument(
    "--access", action="store_true", help="Introspect access token"
)
introspect_token_type.add_argument(
    "--refresh", action="store_true", help="Introspect refresh token"
)
```

**Command Handler Entries:**
```python
"revoke": cmd_revoke,
"introspect": cmd_introspect,
```

IMPORTANT: Both revoke and introspect use `add_mutually_exclusive_group(required=True)` for --access/--refresh flags. This ensures exactly one is provided. The group variable names should differ (revoke_token_type vs introspect_token_type) to avoid collision.
  </action>
  <verify>
```bash
cd demo/client && python -c "
import ast
with open('client-demo.py') as f:
    tree = ast.parse(f.read())
funcs = [node.name for node in ast.walk(tree) if isinstance(node, ast.FunctionDef)]
assert 'cmd_revoke' in funcs, 'cmd_revoke missing'
assert 'cmd_introspect' in funcs, 'cmd_introspect missing'
print('All handlers present')
"
```

Verify mutually exclusive flags work:
```bash
cd demo/client && python client-demo.py revoke --help 2>&1 | grep -E '(--access|--refresh)'
cd demo/client && python client-demo.py introspect --help 2>&1 | grep -E '(--access|--refresh)'
```

Verify no syntax errors:
```bash
cd demo/client && python -c "import ast; ast.parse(open('client-demo.py').read()); print('Syntax OK')"
```

Verify full CLI shows all 9 commands:
```bash
cd demo/client && python client-demo.py --help
```
Expected: generate-keys, generate-verifier, token-exchange, config, refresh, discover, userinfo, revoke, introspect
  </verify>
  <done>cmd_revoke and cmd_introspect exist with private_key_jwt auth (aud = respective endpoint URL), mutually exclusive --access/--refresh flags via argparse groups, registered in CLI, no syntax errors. Full CLI shows all 9 commands.</done>
</task>

</tasks>

<verification>
1. `cd demo/client && python -c "import ast; ast.parse(open('client-demo.py').read()); print('Syntax OK')"` — no syntax errors
2. `cd demo/client && python client-demo.py --help` — shows all 9 commands: generate-keys, generate-verifier, token-exchange, config, refresh, discover, userinfo, revoke, introspect
3. `cd demo/client && python client-demo.py userinfo --help` — shows --agent-id
4. `cd demo/client && python client-demo.py revoke --help` — shows --agent-id, --access, --refresh (mutually exclusive)
5. `cd demo/client && python client-demo.py introspect --help` — shows --agent-id, --access, --refresh (mutually exclusive)
6. All 9 functions exist: hash_access_token, create_dpop_proof, cmd_generate_keys, cmd_generate_verifier, cmd_token_exchange, cmd_config, cmd_refresh, cmd_discover, cmd_userinfo, cmd_revoke, cmd_introspect
7. Revoke aud = revoke endpoint URL (NOT token endpoint)
8. Introspect aud = introspect endpoint URL (NOT token endpoint)
9. Userinfo uses DPoP proof (Authorization: DPoP + DPoP header), NOT private_key_jwt
</verification>

<success_criteria>
- client-demo.py has cmd_userinfo using DPoP-bound access token with create_dpop_proof
- client-demo.py has cmd_revoke with private_key_jwt auth targeting revoke endpoint
- client-demo.py has cmd_introspect with private_key_jwt auth targeting introspect endpoint
- Revoke and introspect have mutually exclusive --access/--refresh flags
- Each endpoint's client_assertion uses the correct aud (its own endpoint URL)
- All subcommands registered in argparse and command_handlers
- File has no syntax errors, CLI shows all 9 commands
- Requirements covered: COAUTH-01 (userinfo), CTOKEN-03 (revoke), COAUTH-02 (introspect)
</success_criteria>

<output>
After completion, create `.planning/phases/37-client-demo-oauth/37-02-SUMMARY.md`
</output>
