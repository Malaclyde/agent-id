---
phase: 27-testing-verification
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/test/integration/shadow-claim-flow.test.ts
  - backend/test/integration/shadow-claim-paddle.test.ts
autonomous: true

must_haves:
  truths:
    - End-to-End backend flow completes successfully
    - Integration tests simulate Paddle Sandbox effectively
  artifacts:
    - path: backend/test/integration/shadow-claim-flow.test.ts
      provides: Integration test suite for full flow
      min_lines: 100
    - path: backend/test/integration/shadow-claim-paddle.test.ts
      provides: Integration test suite for Paddle interactions
      min_lines: 50
  key_links:
    - from: backend/test/integration/shadow-claim-flow.test.ts
      to: backend/src/index.ts
      via: app integration testing
      pattern: "import.*app"
---

<objective>
Implement Integration and End-to-End backend tests for the full shadow claim lifecycle and Paddle Sandbox interactions.

Purpose: Ensure that all backend components integrate smoothly from initiation to payment webhook processing.
Output: Integration tests covering the entire shadow claim flow and Paddle payload validation.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@docs/v1/requirements/agent/shadow-claim.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: End-to-End Backend Flow Test</name>
  <files>backend/test/integration/shadow-claim-flow.test.ts</files>
  <action>
    Create `backend/test/integration/shadow-claim-flow.test.ts`.
    Write an integration test that uses the Hono app instance (or route handlers directly) to simulate the full lifecycle:
    1. Send POST to initiate claim -> verify challenge created.
    2. Send POST to confirm claim with mock DPoP -> verify status is `awaiting-payment`.
    3. Simulate incoming Paddle webhook POST -> verify DB updated and status is `completed`.
    Use an in-memory SQLite DB (or mock D1) and in-memory KV for this test.
  </action>
  <verify>Run `npm run test backend/test/integration/shadow-claim-flow.test.ts` to confirm tests pass.</verify>
  <done>Integration test successfully traverses initiation -> confirmation -> payment webhook.</done>
</task>

<task type="auto">
  <name>Task 2: Integration Tests with mock Paddle Sandbox</name>
  <files>backend/test/integration/shadow-claim-paddle.test.ts</files>
  <action>
    Create `backend/test/integration/shadow-claim-paddle.test.ts`.
    Write tests focusing specifically on Paddle payload structures:
    - Construct realistic mock Paddle `transaction.completed` payloads.
    - Feed them into the webhook endpoint.
    - Verify that `custom_data` parsing handles unexpected formats gracefully (e.g., missing fields).
    - Ensure signature validation logic (if implemented in the handler) correctly rejects invalid signatures and accepts valid ones (mocked).
  </action>
  <verify>Run `npm run test backend/test/integration/shadow-claim-paddle.test.ts` to confirm tests pass.</verify>
  <done>Integration test successfully parses and validates mock Paddle webhook payloads.</done>
</task>

</tasks>

<verification>
- `backend/test/integration/shadow-claim-flow.test.ts` and `backend/test/integration/shadow-claim-paddle.test.ts` exist.
- All integration tests pass when run via `npm test`.
</verification>

<success_criteria>
- End-to-end backend flow tested successfully.
- Paddle Sandbox payload integration tested successfully.
</success_criteria>

<output>
After completion, create `.planning/phases/27-testing-verification/27-03-SUMMARY.md`
</output>
