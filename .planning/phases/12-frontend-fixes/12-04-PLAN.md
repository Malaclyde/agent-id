---
phase: 12-frontend-fixes
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - backend/src/routes/subscriptions.ts
  - frontend/src/api/client.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "POST /v1/subscriptions/cancel endpoint exists and cancels subscription via Paddle"
    - "Frontend can call cancelSubscription API method"
  artifacts:
    - path: "backend/src/routes/subscriptions.ts"
      provides: "Cancel subscription endpoint"
      exports: ["POST /cancel"]
    - path: "frontend/src/api/client.ts"
      provides: "Frontend API method for cancellation"
      contains: "cancelSubscription"
  key_links:
    - from: "backend/src/routes/subscriptions.ts"
      to: "paddle-api.ts"
      via: "cancelSubscription function call"
      pattern: "cancelSubscription.*subscriptionId"
---

<objective>
Create backend endpoint to cancel subscriptions via Paddle API, and wire frontend to call it.

Purpose: Users need ability to cancel/downgrade subscriptions. Subscription continues until end of billing period.
Output: New POST /v1/subscriptions/cancel endpoint + frontend API method
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-frontend-fixes/12-CONTEXT.md
@.planning/phases/12-frontend-fixes/12-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Add POST /v1/subscriptions/cancel backend endpoint</name>
  <files>backend/src/routes/subscriptions.ts</files>
  <action>
1. Add import for cancelSubscription from paddle-api.ts at the top
2. Add new route after the existing routes (after line 238):
   ```typescript
   /**
    * POST /api/subscriptions/cancel - Cancel current subscription
    *
    * Cancels the overseer's subscription through Paddle API.
    * Subscription remains active until end of billing period.
    * Requires authentication.
    */
   subscriptions.post('/cancel', async (c) => {
     const overseerId = c.get('overseerId');
   
     if (!overseerId) {
       return c.json({
         success: false,
         error: 'Authentication required'
       }, 401);
     }
   
     try {
       // Get overseer
       const overseer = await getOverseerById(c.env.DB, overseerId);
       if (!overseer) {
         return c.json({
           success: false,
           error: 'Overseer not found'
         }, 404);
       }
   
       // Get subscription
       const subscription = await getActiveSubscription(c.env.DB, overseerId, c.env);
       
       // Check if there's an active paid subscription
       if (subscription.is_free_tier || !subscription.paddle_subscription_id) {
         return c.json({
           success: false,
           error: 'No active subscription to cancel'
         }, 400);
       }
   
       // Cancel through Paddle
       const canceled = await cancelSubscription(c.env, subscription.paddle_subscription_id);
   
       logEntityAction('subscription_canceled', 'overseer', overseerId, {
         subscription_id: subscription.paddle_subscription_id,
         tier: subscription.tier_id
       });
   
       return c.json({
         success: true,
         message: 'Subscription canceled. It remains active until the end of the current billing period.',
         billing_period_end: subscription.billing_period_end
       });
     } catch (error) {
       const message = error instanceof Error ? error.message : 'Failed to cancel subscription';
       console.error('Cancel subscription error:', error);
       return c.json({ success: false, error: message }, 500);
     }
   });
   ```

3. Verify imports at top include getOverseerById and getActiveSubscription (should already be there)

This implements: "ADD backend endpoint: POST /v1/subscriptions/cancel, Must integrate with Paddle API for proper subscription cancellation"
  </action>
  <verify>
Run `npm run build` in backend directory or use `wrangler types` to verify TypeScript compilation
  </verify>
  <done>
POST /v1/subscriptions/cancel endpoint exists and calls Paddle API to cancel subscription. Returns success with billing_period_end.
  </done>
</task>

<task type="auto">
  <name>Add cancelSubscription method to frontend API client</name>
  <files>frontend/src/api/client.ts</files>
  <action>
1. Find the api object in client.ts
2. Add cancelSubscription method:
   ```typescript
   async cancelSubscription(): Promise<{ message: string; billing_period_end: string | null }> {
     const response = await fetch(`${this.baseUrl}/v1/subscriptions/cancel`, {
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
       },
       credentials: 'include',
     });
     
     const data = await response.json();
     
     if (!response.ok) {
       throw new Error(data.error || 'Failed to cancel subscription');
     }
     
     return data;
   }
   ```

3. Wire up the SubscriptionManagement.tsx cancel button to call this method:
   - Import the api instance
   - In the cancel confirmation modal, call `await api.cancelSubscription()`
   - On success, show success message and refresh subscription data
   - Handle errors with appropriate error message
  </action>
  <verify>
Run `npm run build` in frontend directory to verify TypeScript compilation succeeds
  </verify>
  <done>
Frontend can call api.cancelSubscription() to cancel the subscription via backend API.
  </done>
</task>

</tasks>

<verification>
1. Test backend: curl -X POST https://[backend]/v1/subscriptions/cancel -H "Authorization: Bearer [token]"
2. Verify response includes success: true and billing_period_end
3. Test frontend: Click Cancel Subscription button, confirm cancellation
4. Verify success message appears with billing period end date
</verification>

<success_criteria>
- [ ] POST /v1/subscriptions/cancel endpoint exists in backend
- [ ] Endpoint calls Paddle cancelSubscription API
- [ ] Endpoint returns billing_period_end in response
- [ ] Frontend api.cancelSubscription() method exists
- [ ] Cancel button in UI calls the API
- [ ] TypeScript builds without errors in both backend and frontend
</success_criteria>

<output>
After completion, create `.planning/phases/12-frontend-fixes/12-04-SUMMARY.md`
</output>
