---
phase: 33-agent-demo-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [demos/agent_demo.py, demos/requirements.txt]
autonomous: true
must_haves:
  truths:
    - "User can encode bytes to base64url without padding"
    - "User can decode base64url to bytes with automatic padding"
    - "User can canonicalize JSON objects deterministically"
    - "User can create valid DPoP proof JWTs"
    - "User can generate Ed25519 keypairs"
    - "User can load private keys from base64url strings"
    - "User can validate that public key derives from private key"
  artifacts:
    - path: "demos/agent_demo.py"
      provides: "Core crypto and key management functions"
      min_lines: 100
      exports: ["base64url_encode", "base64url_decode", "base64url_encode_json", "canonicalize", "hash_access_token", "create_dpop_proof", "generate_keypair", "load_private_key", "validate_keys_match"]
    - path: "demos/requirements.txt"
      provides: "Python dependencies"
      contains: "pynacl"
  key_links:
    - from: "base64url_encode"
      to: "pynacl SigningKey"
      via: "key encoding"
      pattern: "base64url_encode\\(bytes\\(.*verify_key\\)\\)"
    - from: "create_dpop_proof"
      to: "SigningKey.sign"
      via: "Ed25519 signature"
      pattern: "private_key\\.sign\\("
---

<objective>
Create the cryptographic foundation for the agent demo script including base64url encoding utilities, canonical JSON serialization, DPoP proof construction, and Ed25519 key management.

Purpose: These utilities are required by all subsequent authentication and registration operations. Ed25519 cryptography must match the backend's @noble/ed25519 implementation exactly.

Output: Working crypto utilities and key management functions with proper base64url handling.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-agent-demo-core/33-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement crypto utilities</name>
  <files>demos/agent_demo.py, demos/requirements.txt</files>
  <action>
Create the `demos/agent_demo.py` file with the following crypto utility functions:

1. **Base64url encoding/decoding:**
   - `base64url_encode(data: bytes) -> str`: Encode bytes to base64url WITHOUT padding (strip trailing `=`)
   - `base64url_decode(data: str) -> bytes`: Decode base64url to bytes, adding padding if needed
   - `base64url_encode_json(obj: dict) -> str`: JSON-encode dict with no whitespace, then base64url

2. **Canonical JSON:**
   - `canonicalize(obj: dict) -> str`: Deterministic JSON serialization per RFC 8785 principles
   - Must sort keys alphabetically
   - Must escape special characters in strings (\\, ", \n, \r, \t)
   - Must produce NO whitespace between elements
   - Booleans as lowercase `true`/`false`, null as `null`

3. **DPoP proof construction:**
   - `hash_access_token(token: str) -> str`: SHA-256 hash of token, base64url encoded
   - `create_dpop_proof(private_key: SigningKey, method: str, uri: str, access_token: str = None) -> str`:
     - Build JWT with header `{typ: "dpop+jwt", alg: "EdDSA", jwk: {kty: "OKP", crv: "Ed25519", x: <public_key>}}`
     - Payload with `{jti: uuid, htm: method, htu: uri, iat: timestamp}`
     - Include `ath` field if access_token provided
     - Sign with Ed25519, return full JWT string

4. **Imports needed:**
   ```python
   import base64
   import json
   import time
   import uuid
   import hashlib
   from nacl.signing import SigningKey, VerifyKey
   from urllib.parse import urlparse
   ```

Create `demos/requirements.txt` with:
```
pynacl>=1.5.0
python-dotenv>=1.0.0
```

CRITICAL: Do NOT use `json.dumps(sort_keys=True)` for canonical JSON - it includes spaces after colons. Implement the custom recursive function from the research.
  </action>
  <verify>
    ```bash
    cd demos && python3 -c "
    from agent_demo import base64url_encode, base64url_decode, canonicalize, hash_access_token
    
    # Test base64url round-trip
    assert base64url_decode(base64url_encode(b'hello')) == b'hello'
    
    # Test no padding
    assert '=' not in base64url_encode(b'test')
    
    # Test canonical JSON
    result = canonicalize({'b': 2, 'a': 1})
    assert result == '{\"a\":1,\"b\":2}', f'Got: {result}'
    
    # Test hash_access_token
    h = hash_access_token('test_token')
    assert len(h) > 0 and '=' not in h
    
    print('All crypto utility tests passed')
    "
    ```
  </verify>
  <done>All crypto utility functions implemented and tested. base64url encoding produces no padding, canonical JSON sorts keys and has no whitespace, DPoP proof structure is correct.</done>
</task>

<task type="auto">
  <name>Task 2: Implement Ed25519 key management</name>
  <files>demos/agent_demo.py</files>
  <action>
Add the following key management functions to `demos/agent_demo.py`:

1. **`generate_keypair() -> tuple[str, str]`:**
   - Generate new Ed25519 keypair using `SigningKey.generate()`
   - Get public key via `private_key.verify_key`
   - Encode both as base64url (32 bytes each)
   - Return `(private_key_b64url, public_key_b64url)`

2. **`load_private_key(private_b64url: str) -> SigningKey`:**
   - Decode base64url to 32 bytes (add padding if needed)
   - Return `SigningKey(private_bytes)`
   - Handle ValueError for invalid key length

3. **`load_public_key(public_b64url: str) -> VerifyKey`:**
   - Decode base64url to 32 bytes
   - Return `VerifyKey(public_bytes)`

4. **`validate_keys_match(private_b64url: str, public_b64url: str) -> bool`:**
   - Load private key
   - Derive public key from it
   - Compare derived public with provided public (both base64url encoded)
   - Return True if match, False otherwise

IMPORTANT: PyNaCl uses 32-byte seed format for private keys. This matches the backend's @noble/ed25519 implementation. Do NOT attempt to use 64-byte expanded format.
  </action>
  <verify>
    ```bash
    cd demos && python3 -c "
    from agent_demo import generate_keypair, load_private_key, validate_keys_match
    
    # Test key generation
    priv, pub = generate_keypair()
    assert len(priv) > 0
    assert len(pub) > 0
    assert priv != pub
    
    # Test key loading
    sk = load_private_key(priv)
    assert sk is not None
    
    # Test validation - matching keys
    assert validate_keys_match(priv, pub) == True
    
    # Test validation - mismatched keys
    priv2, pub2 = generate_keypair()
    assert validate_keys_match(priv, pub2) == False
    
    print('All key management tests passed')
    "
    ```
  </verify>
  <done>All key management functions implemented. Keypairs generate correctly, keys load from base64url, validation confirms public key derives from private key.</done>
</task>

</tasks>

<verification>
1. Run `pip install -r demos/requirements.txt` to verify dependencies
2. Run verification commands in Task 1 and Task 2
3. Verify no import errors: `python3 -c "import agent_demo"` from demos directory
</verification>

<success_criteria>
- base64url_encode produces no padding
- base64url_decode handles both padded and unpadded input
- canonicalize sorts keys alphabetically with no whitespace
- create_dpop_proof generates valid JWT structure
- generate_keypair returns 32-byte keys encoded as base64url
- validate_keys_match correctly identifies matching/mismatched keys
</success_criteria>

<output>
After completion, create `.planning/phases/33-agent-demo-core/33-01-SUMMARY.md`
</output>
