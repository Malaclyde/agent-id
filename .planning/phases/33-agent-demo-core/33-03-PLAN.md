---
phase: 33-agent-demo-core
plan: 03
type: execute
wave: 3
depends_on: [33-02]
files_modified: [demos/agent_demo.py]
autonomous: true
must_haves:
  truths:
    - "User can initiate agent registration with name and public key"
    - "User receives challenge_id and challenge_data from initiate"
    - "User can sign challenge_data with private key"
    - "User can complete registration with signature"
    - "Registration returns agent object and session_id"
  artifacts:
    - path: "demos/agent_demo.py"
      provides: "Agent registration functions"
      exports: ["register_agent_initiate", "register_agent_complete", "register_agent"]
  key_links:
    - from: "register_agent_initiate"
      to: "/api/agents/register/initiate"
      via: "POST request"
      pattern: "register/initiate"
    - from: "register_agent_complete"
      to: "/api/agents/register/complete"
      via: "POST with signature"
      pattern: "register/complete"
    - from: "signature"
      to: "challenge_data"
      via: "Ed25519 sign"
      pattern: "private_key\\.sign\\(challenge_data"
---

<objective>
Implement the two-step agent registration flow with Ed25519 signature verification. The flow consists of initiate (submit name + public key) and complete (submit signature of challenge).

Purpose: Registration is the first authentication operation users perform. It establishes the agent identity with the backend.

Output: Working registration functions that create agents via challenge-response flow (AAUTH-01).
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/33-agent-demo-core/33-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement registration initiate</name>
  <files>demos/agent_demo.py</files>
  <action>
Add the registration initiate function to `demos/agent_demo.py`:

**`register_agent_initiate(backend_url: str, name: str, public_key: str, description: str = None) -> dict`:**

1. Build request body:
   ```python
   body = {'name': name, 'public_key': public_key}
   if description:
       body['description'] = description
   ```

2. Make POST request to `{backend_url}/api/agents/register/initiate`
   - Content-Type: application/json
   - Use `urllib.request.Request` with `method='POST'`

3. Parse response:
   - Returns `{challenge_id: string, expires_at: string, challenge_data: string}`
   - `challenge_data` is already canonicalized by backend - DO NOT re-serialize

4. Return the full response dict

5. Handle errors:
   - Catch `urllib.error.HTTPError` for HTTP errors
   - Parse error JSON and raise with error message
   - Catch `urllib.error.URLError` for network errors

Add necessary imports:
```python
import urllib.request
import urllib.error
```
  </action>
  <verify>
    ```bash
    cd demos && python3 -c "
    from agent_demo import register_agent_initiate, base64url_encode
    from nacl.signing import SigningKey
    
    # Test structure (will fail without backend, but validates function exists)
    import inspect
    sig = inspect.signature(register_agent_initiate)
    params = list(sig.parameters.keys())
    assert 'backend_url' in params
    assert 'name' in params
    assert 'public_key' in params
    
    print('register_agent_initiate function signature verified')
    "
    ```
  </verify>
  <done>register_agent_initiate function implemented. Makes POST to /api/agents/register/initiate with name and public_key.</done>
</task>

<task type="auto">
  <name>Task 2: Implement registration complete and full flow</name>
  <files>demos/agent_demo.py</files>
  <action>
Add the registration complete and combined registration functions to `demos/agent_demo.py`:

1. **`register_agent_complete(backend_url: str, challenge_id: str, private_key: SigningKey, challenge_data: str) -> dict`:**
   - Sign `challenge_data` (as bytes) with `private_key.sign(challenge_data.encode('utf-8'))`
   - Extract signature from `signed.signature`
   - Encode signature as base64url
   - POST to `{backend_url}/api/agents/register/complete/{challenge_id}`
   - Body: `{'signature': signature_b64url}`
   - Return `{agent: {...}, session_id: "..."}`
   - Handle HTTP errors same as initiate

2. **`register_agent(backend_url: str, name: str, private_key: SigningKey, description: str = None) -> dict`:**
   - Convenience function combining both steps
   - Get public key from `private_key.verify_key`
   - Call `register_agent_initiate()`
   - Call `register_agent_complete()`
   - Return final result with agent and session_id

CRITICAL: Sign the `challenge_data` string exactly as returned by backend. Do NOT re-serialize or re-canonicalize. The backend provides pre-canonicalized challenge data.
  </action>
  <verify>
    ```bash
    cd demos && python3 -c "
    from agent_demo import register_agent_complete, register_agent
    from nacl.signing import SigningKey
    import inspect
    
    # Test register_agent_complete signature
    sig = inspect.signature(register_agent_complete)
    params = list(sig.parameters.keys())
    assert 'challenge_id' in params
    assert 'private_key' in params
    assert 'challenge_data' in params
    
    # Test register_agent signature
    sig2 = inspect.signature(register_agent)
    params2 = list(sig2.parameters.keys())
    assert 'backend_url' in params2
    assert 'name' in params2
    assert 'private_key' in params2
    
    # Test signature creation locally
    sk = SigningKey.generate()
    challenge = '{\"test\":\"data\"}'
    signed = sk.sign(challenge.encode('utf-8'))
    assert len(signed.signature) == 64  # Ed25519 signature is 64 bytes
    
    print('Registration functions verified')
    "
    ```
  </verify>
  <done>Full registration flow implemented. register_agent combines initiate and complete steps. Signature is created from challenge_data directly.</done>
</task>

</tasks>

<verification>
1. Run verification commands in Task 1 and Task 2
2. Verify function signatures match expected parameters
3. Verify signature creation uses challenge_data.encode('utf-8') directly
</verification>

<success_criteria>
- register_agent_initiate makes POST to /api/agents/register/initiate
- register_agent_complete signs challenge_data and POSTs to /api/agents/register/complete/{challenge_id}
- register_agent combines both steps into single convenience function
- Signature created from challenge_data string directly (not re-serialized)
</success_criteria>

<output>
After completion, create `.planning/phases/33-agent-demo-core/33-03-SUMMARY.md`
</output>
