---
phase: 30-frontend-test-implementation
plan: 11
type: execute
wave: 5
depends_on: [30-01, 30-02, 30-03, 30-04]
files_modified:
  - frontend/test/unit/pages/subscription-management.test.tsx
autonomous: true
must_haves:
  truths:
    - "Developer can verify SubscriptionManagement shows current subscription details"
    - "Developer can verify upgrade flow opens Paddle checkout"
    - "Developer can verify cancel subscription requires confirmation"
    - "Developer can verify subscription status variations (active, past_due, paused, will_renew: false)"
  artifacts:
    - path: "frontend/test/unit/pages/subscription-management.test.tsx"
      provides: "SubscriptionManagement page tests"
      contains: "describe('SubscriptionManagement'"
  key_links:
    - from: "frontend/test/unit/pages/subscription-management.test.tsx"
      to: "frontend/test/utils/paddle-mock.ts"
      via: "mockPaddle"
      pattern: "mockPaddle\\(\\)"
---

<objective>
Create tests for SubscriptionManagement covering subscription display, upgrade flow with Paddle integration, and cancellation flow.

Purpose: SubscriptionManagement is the most complex page for subscription handling. Tests verify all subscription states and Paddle checkout integration.
Output: Comprehensive SubscriptionManagement tests with Paddle mock usage.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Component to test
@frontend/src/pages/SubscriptionManagement.tsx
</context>

<tasks>

<task type="auto">
  <name>Create SubscriptionManagement page tests</name>
  <files>frontend/test/unit/pages/subscription-management.test.tsx</files>
  <action>
    Create comprehensive tests for SubscriptionManagement. This is a complex component with multiple sub-components and Paddle integration.
    
    ```typescript
    // frontend/test/unit/pages/subscription-management.test.tsx
    import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
    import { screen, waitFor } from '@testing-library/react';
    import userEvent from '@testing-library/user-event';
    import { renderWithAllProviders } from '../../utils/render-helpers';
    import { mockAuthenticatedOverseer, clearAuthMocks } from '../../utils/auth-helpers';
    import { mockPaddle, unmockPaddle, createMockPriceId } from '../../utils/paddle-mock';
    import { server } from '../../mocks/server';
    import { http, HttpResponse } from 'msw';
    import { createMockSubscription, createMockSubscriptionTier, createMockSubscriptionUsage } from '../../factories';
    import SubscriptionManagement from '../../../src/pages/SubscriptionManagement';
    
    describe('SubscriptionManagement', () => {
      const user = userEvent.setup();
      let paddleMock: ReturnType<typeof mockPaddle>;
      
      beforeEach(() => {
        vi.clearAllMocks();
        clearAuthMocks();
        server.resetHandlers();
        mockAuthenticatedOverseer({ id: 'overseer-123' });
        paddleMock = mockPaddle();
      });
      
      afterEach(() => {
        unmockPaddle();
      });
      
      describe('Loading state', () => {
        it('shows loading state initially', () => {
          server.use(
            http.get('/v1/subscriptions/me', async () => {
              await new Promise(resolve => setTimeout(resolve, 100));
              return HttpResponse.json({ success: true, subscription: createMockSubscription() });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          expect(screen.getByText(/loading/i)).toBeInTheDocument();
        });
      });
      
      describe('Current subscription display', () => {
        it('shows subscription tier', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({ tier: 'PRO' }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({
                success: true,
                tiers: [createMockSubscriptionTier({ tier: 'PRO' })],
              });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText('PRO')).toBeInTheDocument();
          });
        });
        
        it('shows usage stats', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  max_agents: 10,
                  max_clients: 20,
                  max_oauth_per_period: 100,
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({
                success: true,
                tiers: [createMockSubscriptionTier()],
              });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage({
                  agents_claimed: 5,
                  clients_registered: 10,
                  oauth_count: 50,
                }),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText(/5.*10/i)).toBeInTheDocument(); // Agents: 5/10
            expect(screen.getByText(/10.*20/i)).toBeInTheDocument(); // Clients: 10/20
          });
        });
        
        it('shows billing period end date', async () => {
          const billingEnd = '2026-03-22T00:00:00Z';
          
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  is_active: true,
                  billing_period_end: billingEnd,
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({ success: true, tiers: [] });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText(/billing.*period.*end/i)).toBeInTheDocument();
          });
        });
      });
      
      describe('Subscription status variations', () => {
        it('shows "Renews on" for active subscription with will_renew: true', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  is_active: true,
                  will_renew: true,
                  billing_period_end: '2026-03-22T00:00:00Z',
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({ success: true, tiers: [] });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText(/renews on/i)).toBeInTheDocument();
          });
        });
        
        it('shows "Cancels on" for subscription with will_renew: false', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  is_active: true,
                  will_renew: false,
                  scheduled_cancel_at: '2026-03-22T00:00:00Z',
                  billing_period_end: '2026-03-22T00:00:00Z',
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({ success: true, tiers: [] });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText(/cancel/i)).toBeInTheDocument();
          });
        });
        
        it('shows "Payment overdue" for past_due status', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  is_active: true,
                  status: 'past_due',
                  will_renew: true,
                  billing_period_end: '2026-03-22T00:00:00Z',
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({ success: true, tiers: [] });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText(/payment.*overdue|overdue/i)).toBeInTheDocument();
          });
        });
        
        it('shows "Paused" for paused status', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  is_active: true,
                  status: 'paused',
                  will_renew: true,
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({ success: true, tiers: [] });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText(/paused/i)).toBeInTheDocument();
          });
        });
        
        it('shows grace period message', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  is_active: false,
                  grace_period_end: '2026-02-28T00:00:00Z',
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({ success: true, tiers: [] });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText(/grace period/i)).toBeInTheDocument();
          });
        });
      });
      
      describe('Upgrade flow', () => {
        it('shows upgrade options for FREE tier', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({ tier: 'FREE' }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({
                success: true,
                tiers: [
                  createMockSubscriptionTier({ tier: 'BASIC', price: 10 }),
                  createMockSubscriptionTier({ tier: 'PRO', price: 25 }),
                  createMockSubscriptionTier({ tier: 'PREMIUM', price: 50 }),
                ],
              });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText(/upgrade.*option/i)).toBeInTheDocument();
            expect(screen.getByText(/basic/i)).toBeInTheDocument();
            expect(screen.getByText(/pro/i)).toBeInTheDocument();
          });
        });
        
        it('opens upgrade modal when tier selected', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({ tier: 'FREE' }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({
                success: true,
                tiers: [
                  createMockSubscriptionTier({ tier: 'PRO', price: 25 }),
                ],
              });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /upgrade.*pro/i })).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /upgrade.*pro/i }));
          
          await waitFor(() => {
            expect(screen.getByText(/confirm.*upgrade/i)).toBeInTheDocument();
          });
        });
        
        it('calls Paddle.Checkout.open with correct parameters', async () => {
          const mockPriceId = createMockPriceId('PRO');
          
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({ tier: 'FREE' }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({
                success: true,
                tiers: [
                  createMockSubscriptionTier({ tier: 'PRO', price: 25 }),
                ],
              });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            }),
            http.post('/v1/subscriptions/upgrade', () => {
              return HttpResponse.json({
                success: true,
                price_id: mockPriceId,
                customer_email: 'test@example.com',
                customer_name: 'Test User',
                tier: 'PRO',
                price: 25,
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /upgrade.*pro/i })).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /upgrade.*pro/i }));
          
          await waitFor(() => {
            expect(screen.getByText(/confirm/i)).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /continue.*checkout/i }));
          
          await waitFor(() => {
            expect(paddleMock.Checkout.open).toHaveBeenCalled();
            expect(paddleMock._lastCheckout()?.items?.[0]?.priceId).toBe(mockPriceId);
            expect(paddleMock._lastCheckout()?.customData?.tier).toBe('PRO');
          });
        });
        
        it('shows highest tier message for PREMIUM users', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({ tier: 'PREMIUM' }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({
                success: true,
                tiers: [createMockSubscriptionTier({ tier: 'PREMIUM' })],
              });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText(/highest.*tier/i)).toBeInTheDocument();
          });
        });
      });
      
      describe('Cancel flow', () => {
        it('shows cancel button for active paid subscription', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  is_active: true,
                  will_renew: true,
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({ success: true, tiers: [] });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /cancel.*subscription/i })).toBeInTheDocument();
          });
        });
        
        it('opens cancel confirmation modal', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  is_active: true,
                  will_renew: true,
                  billing_period_end: '2026-03-22T00:00:00Z',
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({ success: true, tiers: [] });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /cancel.*subscription/i })).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /cancel.*subscription/i }));
          
          await waitFor(() => {
            expect(screen.getByText(/are you sure|cancel subscription/i)).toBeInTheDocument();
          });
        });
        
        it('cancels subscription after confirmation', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  is_active: true,
                  will_renew: true,
                  billing_period_end: '2026-03-22T00:00:00Z',
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({ success: true, tiers: [] });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            }),
            http.post('/v1/subscriptions/cancel', () => {
              return HttpResponse.json({
                success: true,
                message: 'Subscription canceled',
                billing_period_end: '2026-03-22T00:00:00Z',
              });
            })
          );
          
          // Mock alert
          vi.spyOn(window, 'alert').mockImplementation(() => {});
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /cancel.*subscription/i })).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /cancel.*subscription/i }));
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /confirm.*cancel/i })).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /confirm.*cancel/i }));
          
          await waitFor(() => {
            // Subscription should be updated
          });
        });
        
        it('shows renew button for scheduled cancellation', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({
                  tier: 'PRO',
                  is_active: true,
                  will_renew: false,
                  scheduled_cancel_at: '2026-03-22T00:00:00Z',
                }),
              });
            }),
            http.get('/v1/subscriptions/tiers', () => {
              return HttpResponse.json({ success: true, tiers: [] });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage(),
              });
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /renew/i })).toBeInTheDocument();
          });
        });
      });
      
      describe('Error handling', () => {
        it('shows error message on API failure', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json(
                { error: 'Failed to load subscription' },
                { status: 500 }
              );
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByText(/failed|error/i)).toBeInTheDocument();
          });
        });
        
        it('shows retry button on error', async () => {
          server.use(
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json(
                { error: 'Failed to load subscription' },
                { status: 500 }
              );
            })
          );
          
          renderWithAllProviders(<SubscriptionManagement />);
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /retry/i })).toBeInTheDocument();
          });
        });
      });
    });
    ```
  </action>
  <verify>`cd frontend && npm run test:unit -- --run test/unit/pages/subscription-management.test.tsx` passes</verify>
  <done>SubscriptionManagement tests cover subscription display, status variations, upgrade/cancel flows, Paddle integration</done>
</task>

</tasks>

<verification>
1. Test file exists at frontend/test/unit/pages/subscription-management.test.tsx
2. Tests cover current subscription display
3. Tests cover all subscription status variations
4. Tests cover upgrade flow with Paddle mock
5. Tests cover cancel flow
6. All tests pass
</verification>

<success_criteria>
- SubscriptionManagement tests verify tier display and usage stats
- Tests cover status variations: active, past_due, paused, will_renew: false, grace period
- Tests verify upgrade modal opens and calls Paddle.Checkout.open
- Tests verify cancel confirmation modal and cancellation
- Tests verify renew button for scheduled cancellations
</success_criteria>

<output>
After completion, create `.planning/phases/30-frontend-test-implementation/30-11-SUMMARY.md`
</output>