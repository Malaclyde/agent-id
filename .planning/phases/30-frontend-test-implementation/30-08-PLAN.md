---
phase: 30-frontend-test-implementation
plan: 08
type: execute
wave: 4
depends_on: [30-01, 30-02, 30-03, 30-04]
files_modified:
  - frontend/test/unit/pages/registered-clients.test.tsx
autonomous: true
must_haves:
  truths:
    - "Developer can verify RegisteredClients page shows list of OAuth clients"
    - "Developer can verify client registration form works correctly"
    - "Developer can verify client deletion requires confirmation"
    - "Developer can verify empty state shows when no clients exist"
  artifacts:
    - path: "frontend/test/unit/pages/registered-clients.test.tsx"
      provides: "RegisteredClients page tests"
      contains: "describe('RegisteredClients'"
  key_links:
    - from: "frontend/test/unit/pages/registered-clients.test.tsx"
      to: "frontend/test/mocks/handlers/clients.ts"
      via: "MSW handler override"
      pattern: "server.use\\(http\\.(get|post|delete)"
---

<objective>
Create tests for RegisteredClients page covering OAuth client CRUD operations.

Purpose: RegisteredClients tests OAuth client registration, listing, and deletion. Tests form handling and list display patterns.
Output: Comprehensive RegisteredClients tests with MSW mocking.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Component to test
@frontend/src/pages/RegisteredClients.tsx
</context>

<tasks>

<task type="auto">
  <name>Create RegisteredClients page tests</name>
  <files>frontend/test/unit/pages/registered-clients.test.tsx</files>
  <action>
    Create comprehensive tests for RegisteredClients:
    
    ```typescript
    // frontend/test/unit/pages/registered-clients.test.tsx
    import { describe, it, expect, beforeEach, vi } from 'vitest';
    import { screen, waitFor, within } from '@testing-library/react';
    import userEvent from '@testing-library/user-event';
    import { renderWithAllProviders } from '../../utils/render-helpers';
    import { mockAuthenticatedOverseer, clearAuthMocks } from '../../utils/auth-helpers';
    import { server } from '../../mocks/server';
    import { http, HttpResponse } from 'msw';
    import { createMockOAuthClient } from '../../factories';
    import RegisteredClients from '../../../src/pages/RegisteredClients';
    
    describe('RegisteredClients', () => {
      const user = userEvent.setup();
      
      beforeEach(() => {
        vi.clearAllMocks();
        clearAuthMocks();
        server.resetHandlers();
        mockAuthenticatedOverseer();
      });
      
      describe('Loading state', () => {
        it('shows loading state initially', () => {
          // Delay the response
          server.use(
            http.get('/v1/clients/list/:ownerType', async () => {
              await new Promise(resolve => setTimeout(resolve, 100));
              return HttpResponse.json({ success: true, clients: [] });
            })
          );
          
          renderWithAllProviders(<RegisteredClients />);
          
          expect(screen.getByText(/loading/i)).toBeInTheDocument();
        });
      });
      
      describe('Empty state', () => {
        it('shows empty state when no clients exist', async () => {
          server.use(
            http.get('/v1/clients/list/:ownerType', () => {
              return HttpResponse.json({ success: true, clients: [] });
            })
          );
          
          renderWithAllProviders(<RegisteredClients />);
          
          await waitFor(() => {
            expect(screen.getByText(/no.*client/i)).toBeInTheDocument();
          });
        });
      });
      
      describe('Client list', () => {
        it('displays list of registered clients', async () => {
          const mockClients = [
            createMockOAuthClient({ name: 'Client 1', id: 'client-1' }),
            createMockOAuthClient({ name: 'Client 2', id: 'client-2' }),
          ];
          
          server.use(
            http.get('/v1/clients/list/:ownerType', () => {
              return HttpResponse.json({ success: true, clients: mockClients });
            })
          );
          
          renderWithAllProviders(<RegisteredClients />);
          
          await waitFor(() => {
            expect(screen.getByText('Client 1')).toBeInTheDocument();
            expect(screen.getByText('Client 2')).toBeInTheDocument();
          });
        });
        
        it('shows client details including redirect URIs', async () => {
          const mockClient = createMockOAuthClient({
            name: 'Test Client',
            redirect_uris: ['http://localhost:3000/callback'],
          });
          
          server.use(
            http.get('/v1/clients/list/:ownerType', () => {
              return HttpResponse.json({ success: true, clients: [mockClient] });
            })
          );
          
          renderWithAllProviders(<RegisteredClients />);
          
          await waitFor(() => {
            expect(screen.getByText('Test Client')).toBeInTheDocument();
            expect(screen.getByText(/localhost:3000/)).toBeInTheDocument();
          });
        });
      });
      
      describe('Client registration', () => {
        it('shows registration form', async () => {
          server.use(
            http.get('/v1/clients/list/:ownerType', () => {
              return HttpResponse.json({ success: true, clients: [] });
            })
          );
          
          renderWithAllProviders(<RegisteredClients />);
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /register|create|add/i })).toBeInTheDocument();
          });
        });
        
        it('registers a new client successfully', async () => {
          const newClient = createMockOAuthClient({ name: 'New Client' });
          
          server.use(
            http.get('/v1/clients/list/:ownerType', () => {
              return HttpResponse.json({ success: true, clients: [] });
            }),
            http.post('/v1/clients/register/:ownerType', () => {
              return HttpResponse.json({
                success: true,
                client: newClient,
                message: 'Client registered successfully',
              });
            })
          );
          
          renderWithAllProviders(<RegisteredClients />);
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /register|create|add/i })).toBeInTheDocument();
          });
          
          // Open form and fill it
          await user.click(screen.getByRole('button', { name: /register|create|add/i }));
          
          await user.type(screen.getByLabelText(/name/i), 'New Client');
          await user.type(screen.getByLabelText(/redirect/i), 'http://localhost:3000/callback');
          await user.click(screen.getByRole('button', { name: /submit|create/i }));
          
          await waitFor(() => {
            expect(screen.getByText('New Client')).toBeInTheDocument();
          });
        });
        
        it('shows error on registration failure', async () => {
          server.use(
            http.get('/v1/clients/list/:ownerType', () => {
              return HttpResponse.json({ success: true, clients: [] });
            }),
            http.post('/v1/clients/register/:ownerType', () => {
              return HttpResponse.json(
                { error: 'Invalid redirect URI' },
                { status: 400 }
              );
            })
          );
          
          renderWithAllProviders(<RegisteredClients />);
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /register|create|add/i })).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /register|create|add/i }));
          await user.type(screen.getByLabelText(/name/i), 'Test Client');
          await user.type(screen.getByLabelText(/redirect/i), 'invalid-url');
          await user.click(screen.getByRole('button', { name: /submit|create/i }));
          
          await waitFor(() => {
            expect(screen.getByText(/invalid/i)).toBeInTheDocument();
          });
        });
      });
      
      describe('Client deletion', () => {
        it('requires confirmation before deletion', async () => {
          const mockClient = createMockOAuthClient({ name: 'To Delete' });
          
          server.use(
            http.get('/v1/clients/list/:ownerType', () => {
              return HttpResponse.json({ success: true, clients: [mockClient] });
            })
          );
          
          renderWithAllProviders(<RegisteredClients />);
          
          await waitFor(() => {
            expect(screen.getByText('To Delete')).toBeInTheDocument();
          });
          
          // Click delete button
          const deleteButton = screen.getByRole('button', { name: /delete/i });
          await user.click(deleteButton);
          
          // Should show confirmation
          await waitFor(() => {
            expect(screen.getByText(/confirm|are you sure/i)).toBeInTheDocument();
          });
        });
        
        it('deletes client after confirmation', async () => {
          const mockClient = createMockOAuthClient({ name: 'To Delete' });
          
          server.use(
            http.get('/v1/clients/list/:ownerType', () => {
              return HttpResponse.json({ success: true, clients: [mockClient] });
            }),
            http.delete('/v1/clients/:clientId', () => {
              return HttpResponse.json({ success: true, message: 'Client deleted' });
            })
          );
          
          renderWithAllProviders(<RegisteredClients />);
          
          await waitFor(() => {
            expect(screen.getByText('To Delete')).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /delete/i }));
          await user.click(screen.getByRole('button', { name: /confirm/i }));
          
          await waitFor(() => {
            expect(screen.queryByText('To Delete')).not.toBeInTheDocument();
          });
        });
        
        it('cancels deletion if user cancels', async () => {
          const mockClient = createMockOAuthClient({ name: 'Keep Me' });
          
          server.use(
            http.get('/v1/clients/list/:ownerType', () => {
              return HttpResponse.json({ success: true, clients: [mockClient] });
            })
          );
          
          renderWithAllProviders(<RegisteredClients />);
          
          await waitFor(() => {
            expect(screen.getByText('Keep Me')).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /delete/i }));
          await user.click(screen.getByRole('button', { name: /cancel/i }));
          
          // Client should still be visible
          expect(screen.getByText('Keep Me')).toBeInTheDocument();
        });
      });
    });
    ```
    
    Adjust based on actual component implementation.
  </action>
  <verify>`cd frontend && npm run test:unit -- --run test/unit/pages/registered-clients.test.tsx` passes</verify>
  <done>RegisteredClients tests cover list display, CRUD operations, loading/empty states</done>
</task>

</tasks>

<verification>
1. Test file exists at frontend/test/unit/pages/registered-clients.test.tsx
2. Tests cover loading, empty state, client list, registration, deletion
3. All tests pass
</verification>

<success_criteria>
- RegisteredClients tests verify client list display
- Tests cover registration form with success/failure cases
- Tests cover deletion with confirmation flow
- Tests verify loading and empty states
</success_criteria>

<output>
After completion, create `.planning/phases/30-frontend-test-implementation/30-08-SUMMARY.md`
</output>