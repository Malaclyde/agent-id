---
phase: 30-frontend-test-implementation
plan: 04
type: execute
wave: 2
depends_on: [30-01, 30-02]
files_modified:
  - frontend/test/utils/auth-helpers.ts
  - frontend/test/utils/render-helpers.tsx
  - frontend/test/utils/paddle-mock.ts
autonomous: true
must_haves:
  truths:
    - "Developer can use renderWithAuth to render components with AuthProvider context"
    - "Developer can use mockAuthenticatedAgent to set up agent auth state"
    - "Developer can use mockAuthenticatedOverseer to set up overseer auth state"
    - "Developer can use mockPaddle to spy on Paddle.Checkout.open calls"
  artifacts:
    - path: "frontend/test/utils/auth-helpers.ts"
      provides: "Auth state mocking utilities"
      exports: ["mockAuthenticatedAgent", "mockAuthenticatedOverseer", "mockUnauthenticated"]
    - path: "frontend/test/utils/render-helpers.tsx"
      provides: "Render with context providers"
      exports: ["renderWithAuth", "renderWithRouter", "renderWithAllProviders"]
    - path: "frontend/test/utils/paddle-mock.ts"
      provides: "Paddle.js mocking"
      exports: ["mockPaddle", "PaddleMock"]
  key_links:
    - from: "frontend/test/utils/render-helpers.tsx"
      to: "frontend/test/utils/auth-helpers.ts"
      via: "import for auth state setup"
      pattern: "mockAuthenticated"
---

<objective>
Create test utilities for auth state mocking, rendering with context providers, and Paddle.js mocking.

Purpose: These utilities reduce boilerplate in tests by providing common setup patterns. Auth helpers manage localStorage/session state, render helpers wrap components with required providers, Paddle mock enables testing checkout flows.
Output: auth-helpers.ts, render-helpers.tsx, paddle-mock.ts
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Context providers and auth
@frontend/src/context/AuthContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Create auth state helpers</name>
  <files>frontend/test/utils/auth-helpers.ts</files>
  <action>
    Create utilities for mocking auth state in localStorage:
    
    ```typescript
    // frontend/test/utils/auth-helpers.ts
    import { vi } from 'vitest';
    import type { Agent, Overseer } from '../../src/types';
    import { createMockAgent, createMockOverseer } from '../factories';
    
    const SESSION_ID_KEY = 'sessionId';
    const AUTH_TYPE_KEY = 'authType';
    
    export interface MockAuthState {
      sessionId: string | null;
      authType: 'agent' | 'overseer' | null;
      user: Agent | Overseer | null;
    }
    
    /**
     * Mock authenticated agent state in localStorage
     */
    export function mockAuthenticatedAgent(
      overrides: Partial<Agent> = {},
      sessionId: string = 'test-agent-session'
    ): MockAuthState {
      const agent = createMockAgent(overrides);
      
      vi.mocked(localStorage.getItem).mockImplementation((key: string) => {
        if (key === SESSION_ID_KEY) return sessionId;
        if (key === AUTH_TYPE_KEY) return 'agent';
        return null;
      });
      
      return {
        sessionId,
        authType: 'agent',
        user: agent,
      };
    }
    
    /**
     * Mock authenticated overseer state in localStorage
     */
    export function mockAuthenticatedOverseer(
      overrides: Partial<Overseer> = {},
      sessionId: string = 'test-overseer-session'
    ): MockAuthState {
      const overseer = createMockOverseer(overrides);
      
      vi.mocked(localStorage.getItem).mockImplementation((key: string) => {
        if (key === SESSION_ID_KEY) return sessionId;
        if (key === AUTH_TYPE_KEY) return 'overseer';
        return null;
      });
      
      return {
        sessionId,
        authType: 'overseer',
        user: overseer,
      };
    }
    
    /**
     * Mock unauthenticated state (no session)
     */
    export function mockUnauthenticated(): MockAuthState {
      vi.mocked(localStorage.getItem).mockReturnValue(null);
      
      return {
        sessionId: null,
        authType: null,
        user: null,
      };
    }
    
    /**
     * Clear all auth mocks
     */
    export function clearAuthMocks(): void {
      vi.mocked(localStorage.getItem).mockReset();
      vi.mocked(localStorage.setItem).mockReset();
      vi.mocked(localStorage.removeItem).mockReset();
    }
    ```
  </action>
  <verify>File exports mockAuthenticatedAgent, mockAuthenticatedOverseer, mockUnauthenticated, clearAuthMocks</verify>
  <done>Auth helpers created with functions to mock agent/overseer auth state and clear mocks</done>
</task>

<task type="auto">
  <name>Create render helpers with context providers</name>
  <files>frontend/test/utils/render-helpers.tsx</files>
  <action>
    Create render utilities that wrap components with required providers:
    
    ```typescript
    // frontend/test/utils/render-helpers.tsx
    import { ReactElement } from 'react';
    import { render, RenderOptions } from '@testing-library/react';
    import { BrowserRouter } from 'react-router-dom';
    import { AuthProvider } from '../../src/context/AuthContext';
    
    interface CustomRenderOptions extends Omit<RenderOptions, 'wrapper'> {
      route?: string;
      withAuth?: boolean;
    }
    
    /**
     * Render with React Router's BrowserRouter
     */
    export function renderWithRouter(
      ui: ReactElement,
      options: CustomRenderOptions = {}
    ) {
      const { route = '/', ...renderOptions } = options;
      
      // Update window.location if route specified
      if (route !== '/') {
        window.history.pushState({}, '', route);
      }
      
      return render(ui, {
        wrapper: ({ children }) => (
          <BrowserRouter>{children}</BrowserRouter>
        ),
        ...renderOptions,
      });
    }
    
    /**
     * Render with AuthProvider only
     */
    export function renderWithAuth(
      ui: ReactElement,
      options: CustomRenderOptions = {}
    ) {
      const { ...renderOptions } = options;
      
      return render(ui, {
        wrapper: ({ children }) => (
          <AuthProvider>{children}</AuthProvider>
        ),
        ...renderOptions,
      });
    }
    
    /**
     * Render with all common providers (Router + Auth)
     */
    export function renderWithAllProviders(
      ui: ReactElement,
      options: CustomRenderOptions = {}
    ) {
      const { route = '/', ...renderOptions } = options;
      
      if (route !== '/') {
        window.history.pushState({}, '', route);
      }
      
      return render(ui, {
        wrapper: ({ children }) => (
          <BrowserRouter>
            <AuthProvider>{children}</AuthProvider>
          </BrowserRouter>
        ),
        ...renderOptions,
      });
    }
    
    // Re-export everything from testing-library
    export * from '@testing-library/react';
    export { screen, waitFor, within } from '@testing-library/react';
    ```
  </action>
  <verify>File exports renderWithRouter, renderWithAuth, renderWithAllProviders and re-exports testing-library</verify>
  <done>Render helpers created with functions to wrap components with Router and/or AuthProvider</done>
</task>

<task type="auto">
  <name>Create Paddle.js mock utility</name>
  <files>frontend/test/utils/paddle-mock.ts</files>
  <action>
    Create a mock for Paddle.js that tracks checkout calls:
    
    ```typescript
    // frontend/test/utils/paddle-mock.ts
    import { vi } from 'vitest';
    
    export interface PaddleCheckoutOptions {
      settings?: {
        displayMode?: string;
        theme?: string;
        allowLogout?: boolean;
        successUrl?: string;
      };
      items?: Array<{
        priceId: string;
        quantity: number;
      }>;
      customer?: {
        email?: string;
        name?: string;
      };
      customData?: Record<string, any>;
    }
    
    export interface PaddleMock {
      Checkout: {
        open: ReturnType<typeof vi.fn>;
      };
      Setup: ReturnType<typeof vi.fn>;
      _checkoutCalls: PaddleCheckoutOptions[];
      _lastCheckout: () => PaddleCheckoutOptions | undefined;
      _reset: () => void;
    }
    
    /**
     * Create and install a Paddle.js mock on window
     */
    export function mockPaddle(): PaddleMock {
      const checkoutCalls: PaddleCheckoutOptions[] = [];
      
      const paddleMock: PaddleMock = {
        Checkout: {
          open: vi.fn((options: PaddleCheckoutOptions) => {
            checkoutCalls.push(options);
          }),
        },
        Setup: vi.fn(),
        _checkoutCalls: checkoutCalls,
        _lastCheckout: () => checkoutCalls[checkoutCalls.length - 1],
        _reset: () => {
          checkoutCalls.length = 0;
          paddleMock.Checkout.open.mockClear();
        },
      };
      
      // Install on window
      (window as any).Paddle = paddleMock;
      
      return paddleMock;
    }
    
    /**
     * Remove Paddle mock from window
     */
    export function unmockPaddle(): void {
      delete (window as any).Paddle;
    }
    
    /**
     * Create a mock Paddle price ID
     */
    export function createMockPriceId(tier: string = 'PRO'): string {
      return `pri_${tier.toLowerCase()}_${Math.random().toString(36).substr(2, 9)}`;
    }
    ```
  </action>
  <verify>File exports mockPaddle, unmockPaddle, createMockPriceId and PaddleMock interface</verify>
  <done>Paddle mock created with Checkout.open tracking, reset functionality, and helper for mock price IDs</done>
</task>

</tasks>

<verification>
1. frontend/test/utils/auth-helpers.ts exists with auth mocking functions
2. frontend/test/utils/render-helpers.tsx exists with render wrappers
3. frontend/test/utils/paddle-mock.ts exists with Paddle mocking
4. All functions are properly typed with TypeScript
</verification>

<success_criteria>
- mockAuthenticatedAgent and mockAuthenticatedOverseer set up localStorage mocks
- renderWithRouter, renderWithAuth, renderWithAllProviders wrap components correctly
- mockPaddle installs Paddle.Checkout.open spy on window and tracks calls
- Utilities use existing test factories for mock data
</success_criteria>

<output>
After completion, create `.planning/phases/30-frontend-test-implementation/30-04-SUMMARY.md`
</output>