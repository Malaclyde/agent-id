---
phase: 30-frontend-test-implementation
plan: 06
type: execute
wave: 3
depends_on: [30-01, 30-02, 30-03, 30-04]
files_modified:
  - frontend/test/unit/context/auth-context.test.tsx
autonomous: true
must_haves:
  truths:
    - "Developer can verify AuthContext initializes with correct state"
    - "Developer can verify loginAsOverseer updates auth state correctly"
    - "Developer can verify registerAsOverseer updates auth state correctly"
    - "Developer can verify session restoration from localStorage works"
    - "Developer can verify logout clears auth state"
  artifacts:
    - path: "frontend/test/unit/context/auth-context.test.tsx"
      provides: "AuthContext tests"
      contains: "describe('AuthContext'"
  key_links:
    - from: "frontend/test/unit/context/auth-context.test.tsx"
      to: "frontend/test/mocks/handlers/overseers.ts"
      via: "MSW handler override"
      pattern: "server.use\\(http\\.(get|post)"
---

<objective>
Update AuthContext tests to use MSW for API mocking instead of vi.mock, providing more realistic testing of the auth flow.

Purpose: AuthContext is the foundation of auth state management. Tests should verify login, registration, logout, and session restoration using MSW.
Output: Comprehensive AuthContext tests using MSW.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# AuthContext to test
@frontend/src/context/AuthContext.tsx

# Existing test to update
@frontend/test/unit/auth-context.test.tsx
</context>

<tasks>

<task type="auto">
  <name>Update AuthContext tests to use MSW</name>
  <files>frontend/test/unit/context/auth-context.test.tsx</files>
  <action>
    Rewrite the existing auth-context.test.tsx to use MSW instead of vi.mock for the api client.
    
    Create the test file in `frontend/test/unit/context/` directory:
    
    ```typescript
    import { describe, it, expect, beforeEach, vi } from 'vitest';
    import { screen, waitFor, act } from '@testing-library/react';
    import { renderWithAuth } from '../../utils/render-helpers';
    import { mockUnauthenticated, mockAuthenticatedOverseer, mockAuthenticatedAgent, clearAuthMocks } from '../../utils/auth-helpers';
    import { server } from '../../mocks/server';
    import { http, HttpResponse } from 'msw';
    import { createMockOverseer, createMockAgent } from '../../factories';
    import { AuthProvider, useAuth } from '../../../src/context/AuthContext';
    
    // Test component to access AuthContext
    function TestComponent() {
      const { isLoading, authType, user, sessionId, loginAsOverseer, registerAsOverseer, logout } = useAuth();
      
      return (
        <div>
          <span data-testid="loading">{isLoading ? 'loading' : 'not-loading'}</span>
          <span data-testid="auth-type">{authType || 'none'}</span>
          <span data-testid="user">{user ? JSON.stringify(user) : 'null'}</span>
          <span data-testid="session-id">{sessionId || 'null'}</span>
          <button data-testid="login-btn" onClick={() => loginAsOverseer('test@example.com', 'password')}>Login</button>
          <button data-testid="register-btn" onClick={() => registerAsOverseer('Test User', 'test@example.com', 'password')}>Register</button>
          <button data-testid="logout-btn" onClick={logout}>Logout</button>
        </div>
      );
    }
    
    describe('AuthContext', () => {
      beforeEach(() => {
        vi.clearAllMocks();
        clearAuthMocks();
        server.resetHandlers();
      });
      
      describe('Initial state', () => {
        it('provides correct initial state when not authenticated', async () => {
          mockUnauthenticated();
          
          renderWithAuth(<TestComponent />);
          
          await waitFor(() => {
            expect(screen.getByTestId('loading')).toHaveTextContent('not-loading');
          });
          
          expect(screen.getByTestId('auth-type')).toHaveTextContent('none');
          expect(screen.getByTestId('user')).toHaveTextContent('null');
          expect(screen.getByTestId('session-id')).toHaveTextContent('null');
        });
        
        it('shows loading state initially', () => {
          mockUnauthenticated();
          
          renderWithAuth(<TestComponent />);
          
          // Initially should be loading
          expect(screen.getByTestId('loading')).toHaveTextContent('loading');
        });
      });
      
      describe('loginAsOverseer', () => {
        it('updates state when login succeeds', async () => {
          mockUnauthenticated();
          
          const mockOverseer = createMockOverseer({ email: 'test@example.com' });
          
          server.use(
            http.post('/v1/overseers/login', () => {
              return HttpResponse.json({
                success: true,
                overseer: mockOverseer,
                session_id: 'session-123',
              });
            })
          );
          
          renderWithAuth(<TestComponent />);
          
          await waitFor(() => {
            expect(screen.getByTestId('loading')).toHaveTextContent('not-loading');
          });
          
          await act(async () => {
            screen.getByTestId('login-btn').click();
          });
          
          await waitFor(() => {
            expect(screen.getByTestId('auth-type')).toHaveTextContent('overseer');
          });
          
          expect(screen.getByTestId('session-id')).toHaveTextContent('session-123');
        });
        
        it('handles login failure', async () => {
          mockUnauthenticated();
          
          server.use(
            http.post('/v1/overseers/login', () => {
              return HttpResponse.json(
                { error: 'Invalid credentials' },
                { status: 401 }
              );
            })
          );
          
          renderWithAuth(<TestComponent />);
          
          await waitFor(() => {
            expect(screen.getByTestId('loading')).toHaveTextContent('not-loading');
          });
          
          await act(async () => {
            screen.getByTestId('login-btn').click();
          });
          
          // Should remain unauthenticated
          await waitFor(() => {
            expect(screen.getByTestId('auth-type')).toHaveTextContent('none');
          });
        });
      });
      
      describe('registerAsOverseer', () => {
        it('updates state when registration succeeds', async () => {
          mockUnauthenticated();
          
          const mockOverseer = createMockOverseer({ name: 'New User', email: 'new@example.com' });
          
          server.use(
            http.post('/v1/overseers/register', () => {
              return HttpResponse.json({
                success: true,
                overseer: mockOverseer,
                session_id: 'new-session-456',
              });
            })
          );
          
          renderWithAuth(<TestComponent />);
          
          await waitFor(() => {
            expect(screen.getByTestId('loading')).toHaveTextContent('not-loading');
          });
          
          await act(async () => {
            screen.getByTestId('register-btn').click();
          });
          
          await waitFor(() => {
            expect(screen.getByTestId('auth-type')).toHaveTextContent('overseer');
          });
        });
      });
      
      describe('logout', () => {
        it('clears state when logout is called', async () => {
          mockAuthenticatedOverseer({}, 'session-789');
          
          server.use(
            http.post('/v1/overseers/logout', () => {
              return HttpResponse.json({ success: true, message: 'Logged out' });
            })
          );
          
          renderWithAuth(<TestComponent />);
          
          await waitFor(() => {
            expect(screen.getByTestId('loading')).toHaveTextContent('not-loading');
          });
          
          await act(async () => {
            screen.getByTestId('logout-btn').click();
          });
          
          await waitFor(() => {
            expect(screen.getByTestId('auth-type')).toHaveTextContent('none');
          });
        });
      });
      
      describe('Session restoration', () => {
        it('restores overseer session from localStorage on mount', async () => {
          const mockOverseer = createMockOverseer();
          mockAuthenticatedOverseer(mockOverseer);
          
          server.use(
            http.get('/v1/overseers/me', () => {
              return HttpResponse.json({
                success: true,
                overseer: mockOverseer,
              });
            })
          );
          
          renderWithAuth(<TestComponent />);
          
          await waitFor(() => {
            expect(screen.getByTestId('auth-type')).toHaveTextContent('overseer');
          });
        });
        
        it('restores agent session from localStorage on mount', async () => {
          const mockAgent = createMockAgent();
          mockAuthenticatedAgent(mockAgent);
          
          server.use(
            http.get('/v1/agents/me', () => {
              return HttpResponse.json({
                success: true,
                agent: mockAgent,
              });
            })
          );
          
          renderWithAuth(<TestComponent />);
          
          await waitFor(() => {
            expect(screen.getByTestId('auth-type')).toHaveTextContent('agent');
          });
        });
        
        it('clears session if session validation fails', async () => {
          mockAuthenticatedOverseer();
          
          server.use(
            http.get('/v1/overseers/me', () => {
              return HttpResponse.json(
                { error: 'Unauthorized' },
                { status: 401 }
              );
            })
          );
          
          renderWithAuth(<TestComponent />);
          
          await waitFor(() => {
            expect(screen.getByTestId('auth-type')).toHaveTextContent('none');
          });
        });
      });
      
      describe('useAuth hook', () => {
        it('throws error when used outside AuthProvider', () => {
          const consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});
          
          expect(() => {
            renderWithAuth(<TestComponent />);
          }).not.toThrow(); // With AuthProvider, should not throw
          
          consoleSpy.mockRestore();
        });
      });
    });
    ```
    
    Create the context directory if needed: `mkdir -p frontend/test/unit/context`
  </action>
  <verify>`cd frontend && npm run test:unit -- --run test/unit/context/auth-context.test.tsx` passes</verify>
  <done>AuthContext tests use MSW, cover login, register, logout, session restoration</done>
</task>

</tasks>

<verification>
1. Test file exists at frontend/test/unit/context/auth-context.test.tsx
2. Tests use MSW handlers instead of vi.mock
3. Tests cover: initial state, login, register, logout, session restoration
4. All tests pass
</verification>

<success_criteria>
- AuthContext tests use MSW for realistic API mocking
- Tests verify login/register success and failure paths
- Tests verify session restoration for both overseer and agent
- Tests verify logout clears state
</success_criteria>

<output>
After completion, create `.planning/phases/30-frontend-test-implementation/30-06-SUMMARY.md`
</output>