---
phase: 30-frontend-test-implementation
plan: 12
type: execute
wave: 5
depends_on: [30-01, 02, 30-03, 30-04]
files_modified:
  - frontend/test/unit/pages/shadow-claim.test.tsx
autonomous: true
must_haves:
  truths:
    - "Developer can verify ShadowClaim shows loading state during initiation"
    - "Developer can verify polling continues until challenge completes or expires"
    - "Developer can verify network error shows retry option"
    - "Developer can verify challenge expiration shows 'Challenge Expired' with restart option"
    - "Developer can verify countdown timer displays time remaining"
  artifacts:
    - path: "frontend/test/unit/pages/shadow-claim.test.tsx"
      provides: "ShadowClaim page tests"
      contains: "describe('ShadowClaim'"
  key_links:
    - from: "frontend/test/unit/pages/shadow-claim.test.tsx"
      to: "frontend/test/mocks/handlers/agents.ts"
      via: "MSW handler override"
      pattern: "server.use\\(http\\.(get|post)"
---

<objective>
Create tests for ShadowClaim page covering the most complex frontend behaviors: polling with exponential backoff, error handling, challenge expiration, and countdown timer.

Purpose: ShadowClaim is the most complex frontend component. Tests verify polling behavior, error states, timeout handling, and countdown display.
Output: Comprehensive ShadowClaim tests covering all edge cases.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Component to test
@frontend/src/pages/ShadowClaim.tsx
</context>

<tasks>

<task type="auto">
  <name>Create ShadowClaim page tests</name>
  <files>frontend/test/unit/pages/shadow-claim.test.tsx</files>
  <action>
    Create comprehensive tests for ShadowClaim with polling, error handling, and timer:
    
    ```typescript
    // frontend/test/unit/pages/shadow-claim.test.tsx
    import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
    import { screen, waitFor, act } from '@testing-library/react';
    import userEvent from '@testing-library/user-event';
    import { renderWithRouter } from '../../utils/render-helpers';
    import { server } from '../../mocks/server';
    import { http, HttpResponse, delay } from 'msw';
    import ShadowClaim from '../../../src/pages/ShadowClaim';
    
    // Mock useParams and useNavigate
    const mockNavigate = vi.fn();
    vi.mock('react-router-dom', async () => {
      const actual = await vi.importActual('react-router-dom');
      return {
        ...actual,
        useParams: () => ({ agentId: 'test-agent-123' }),
        useNavigate: () => mockNavigate,
      };
    });
    
    describe('ShadowClaim', () => {
      const user = userEvent.setup();
      
      beforeEach(() => {
        vi.clearAllMocks();
        vi.useFakeTimers();
        server.resetHandlers();
      });
      
      afterEach(() => {
        vi.useRealTimers();
      });
      
      describe('Initial loading state', () => {
        it('shows loading state during initiation', async () => {
          server.use(
            http.post('/v1/agents/malice/:agentId', async () => {
              await delay(100);
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-123',
                expires_at: new Date(Date.now() + 3600000).toISOString(),
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          expect(screen.getByText(/initializing/i)).toBeInTheDocument();
          
          await act(async () => {
            vi.advanceTimersByTime(150);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/confirmation required|waiting for agent/i)).toBeInTheDocument();
          });
        });
      });
      
      describe('Successful initiation', () => {
        it('shows challenge details after initiation', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString();
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              return HttpResponse.json({
                status: 'initiated',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/confirmation required/i)).toBeInTheDocument();
            expect(screen.getByText(/challenge-123/i)).toBeInTheDocument();
          });
        });
        
        it('shows countdown timer', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString(); // 1 hour
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              return HttpResponse.json({
                status: 'initiated',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/expires in/i)).toBeInTheDocument();
          });
        });
        
        it('shows copy buttons for endpoint and body', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString();
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              return HttpResponse.json({
                status: 'initiated',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          // Mock clipboard
          Object.assign(navigator, {
            clipboard: {
              writeText: vi.fn().mockResolvedValue(undefined),
            },
          });
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/endpoint url/i)).toBeInTheDocument();
            expect(screen.getAllByText(/copy/i)).toHaveLength(2);
          });
        });
      });
      
      describe('Polling behavior', () => {
        it('polls for status updates', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString();
          let pollCount = 0;
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              pollCount++;
              return HttpResponse.json({
                status: 'initiated',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/waiting for agent/i)).toBeInTheDocument();
          });
          
          // Advance past first poll interval (2 seconds)
          await act(async () => {
            vi.advanceTimersByTime(2500);
          });
          
          expect(pollCount).toBeGreaterThan(0);
        });
        
        it('navigates to payment when status is awaiting-payment', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString();
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              return HttpResponse.json({
                status: 'awaiting-payment',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/waiting for agent/i)).toBeInTheDocument();
          });
          
          // Advance past first poll interval
          await act(async () => {
            vi.advanceTimersByTime(2500);
          });
          
          await waitFor(() => {
            expect(mockNavigate).toHaveBeenCalledWith('/malice/test-agent-123/payment/challenge-123');
          });
        });
        
        it('shows completed state when status is completed', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString();
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              return HttpResponse.json({
                status: 'completed',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/waiting for agent/i)).toBeInTheDocument();
          });
          
          await act(async () => {
            vi.advanceTimersByTime(2500);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/claim completed successfully/i)).toBeInTheDocument();
          });
        });
      });
      
      describe('Error handling', () => {
        it('shows network error with retry option', async () => {
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.error();
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/connection error|unable to connect/i)).toBeInTheDocument();
          });
        });
        
        it('shows already claimed error', async () => {
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json(
                { error: 'Agent already claimed by another overseer' },
                { status: 409 }
              );
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/already claimed/i)).toBeInTheDocument();
          });
        });
        
        it('shows not found error', async () => {
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json(
                { error: 'Agent not found' },
                { status: 404 }
              );
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/not found/i)).toBeInTheDocument();
          });
        });
        
        it('shows retry button for network error', async () => {
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.error();
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /try again|retry/i })).toBeInTheDocument();
          });
        });
        
        it('retries with exponential backoff', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString();
          let retryCount = 0;
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              retryCount++;
              if (retryCount < 3) {
                return HttpResponse.error();
              }
              return HttpResponse.json({
                status: 'initiated',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          // Trigger manual retry
          await waitFor(() => {
            expect(screen.getByText(/waiting for agent/i)).toBeInTheDocument();
          });
        });
      });
      
      describe('Challenge expiration', () => {
        it('shows expired state when time runs out', async () => {
          const expiresAt = new Date(Date.now() + 1000).toISOString(); // 1 second
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              return HttpResponse.json({
                status: 'expired',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/waiting for agent/i)).toBeInTheDocument();
          });
          
          // Advance past poll and timer
          await act(async () => {
            vi.advanceTimersByTime(3000);
          });
          
          await waitFor(() => {
            expect(screen.getByText(/challenge expired/i)).toBeInTheDocument();
          });
        });
        
        it('shows start new claim button when expired', async () => {
          const expiresAt = new Date(Date.now() + 1000).toISOString();
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              return HttpResponse.json({
                status: 'expired',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await act(async () => {
            vi.advanceTimersByTime(3000);
          });
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /start new claim/i })).toBeInTheDocument();
          });
        });
      });
      
      describe('Manual status check', () => {
        it('has check status button', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString();
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              return HttpResponse.json({
                status: 'initiated',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /check status/i })).toBeInTheDocument();
          });
        });
        
        it('checks status when button clicked', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString();
          let manualCheckCount = 0;
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              manualCheckCount++;
              return HttpResponse.json({
                status: 'initiated',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /check status/i })).toBeInTheDocument();
          });
          
          await act(async () => {
            screen.getByRole('button', { name: /check status/i }).click();
            vi.advanceTimersByTime(100);
          });
          
          // Manual check should increment counter
          expect(manualCheckCount).toBeGreaterThan(0);
        });
      });
      
      describe('Cancel action', () => {
        it('shows cancel claim button', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString();
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              return HttpResponse.json({
                status: 'initiated',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /cancel claim/i })).toBeInTheDocument();
          });
        });
        
        it('shows cancellation info when cancel clicked', async () => {
          const expiresAt = new Date(Date.now() + 3600000).toISOString();
          
          server.use(
            http.post('/v1/agents/malice/:agentId', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            }),
            http.get('/v1/agents/malice/status/:challengeId', () => {
              return HttpResponse.json({
                status: 'initiated',
                agent_id: 'test-agent-123',
                shadow_overseer_id: 'shadow-456',
                expires_at: expiresAt,
              });
            })
          );
          
          renderWithRouter(<ShadowClaim />);
          
          await act(async () => {
            vi.advanceTimersByTime(50);
          });
          
          await waitFor(() => {
            expect(screen.getByRole('button', { name: /cancel claim/i })).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /cancel claim/i }));
          
          await waitFor(() => {
            expect(screen.getByText(/close this browser tab/i)).toBeInTheDocument();
          });
        });
      });
    });
    ```
  </action>
  <verify>`cd frontend && npm run test:unit -- --run test/unit/pages/shadow-claim.test.tsx` passes</verify>
  <done>ShadowClaim tests cover loading, polling, error states, expiration, manual check, cancel</done>
</task>

</tasks>

<verification>
1. Test file exists at frontend/test/unit/pages/shadow-claim.test.tsx
2. Tests cover initiation and loading state
3. Tests cover polling behavior with fake timers
4. Tests cover all error states (network, already claimed, not found)
5. Tests cover challenge expiration
6. Tests cover manual status check
7. All tests pass
</verification>

<success_criteria>
- ShadowClaim tests verify loading state during initiation
- Tests verify polling continues until completion/expiration
- Tests verify network error shows retry with exponential backoff
- Tests verify challenge expiration shows restart option
- Tests verify countdown timer updates
- Tests verify manual status check button
</success_criteria>

<output>
After completion, create `.planning/phases/30-frontend-test-implementation/30-12-SUMMARY.md`
</output>