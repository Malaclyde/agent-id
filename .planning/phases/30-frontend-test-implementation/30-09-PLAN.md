---
phase: 30-frontend-test-implementation
plan: 09
type: execute
wave: 4
depends_on: [30-01, 30-02, 30-03, 30-04]
files_modified:
  - frontend/test/unit/pages/overseer-dashboard.test.tsx
autonomous: true
must_haves:
  truths:
    - "Developer can verify OverseerDashboard shows list of claimed agents"
    - "Developer can verify agent claim flow initiates correctly"
    - "Developer can verify declaim agent requires confirmation"
    - "Developer can verify downgrade modal shows when over agent limit"
  artifacts:
    - path: "frontend/test/unit/pages/overseer-dashboard.test.tsx"
      provides: "OverseerDashboard page tests"
      contains: "describe('OverseerDashboard'"
  key_links:
    - from: "frontend/test/unit/pages/overseer-dashboard.test.tsx"
      to: "frontend/test/mocks/handlers/agents.ts"
      via: "MSW handler override"
      pattern: "server.use\\(http\\.(get|post)"
---

<objective>
Create tests for OverseerDashboard covering agent management, claim flow, declaim, and downgrade modal.

Purpose: OverseerDashboard is the main management interface for overseers. Tests verify agent listing, claiming, declaiming, and subscription limit handling.
Output: Comprehensive OverseerDashboard tests.
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Component to test
@frontend/src/pages/OverseerDashboard.tsx
</context>

<tasks>

<task type="auto">
  <name>Create OverseerDashboard page tests</name>
  <files>frontend/test/unit/pages/overseer-dashboard.test.tsx</files>
  <action>
    Create comprehensive tests for OverseerDashboard:
    
    ```typescript
    // frontend/test/unit/pages/overseer-dashboard.test.tsx
    import { describe, it, expect, beforeEach, vi } from 'vitest';
    import { screen, waitFor } from '@testing-library/react';
    import userEvent from '@testing-library/user-event';
    import { renderWithAllProviders } from '../../utils/render-helpers';
    import { mockAuthenticatedOverseer, clearAuthMocks } from '../../utils/auth-helpers';
    import { server } from '../../mocks/server';
    import { http, HttpResponse } from 'msw';
    import { createMockAgent, createMockSubscription, createMockSubscriptionUsage } from '../../factories';
    import OverseerDashboard from '../../../src/pages/OverseerDashboard';
    
    describe('OverseerDashboard', () => {
      const user = userEvent.setup();
      
      beforeEach(() => {
        vi.clearAllMocks();
        clearAuthMocks();
        server.resetHandlers();
        mockAuthenticatedOverseer({ id: 'overseer-123', name: 'Test Overseer' });
      });
      
      describe('Loading state', () => {
        it('shows loading state initially', () => {
          server.use(
            http.get('/v1/overseers/me/agents', async () => {
              await new Promise(resolve => setTimeout(resolve, 100));
              return HttpResponse.json({ success: true, agents: [] });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({ success: true, subscription: createMockSubscription() });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({ success: true, usage: createMockSubscriptionUsage() });
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          expect(screen.getByText(/loading/i)).toBeInTheDocument();
        });
      });
      
      describe('Agent list', () => {
        it('displays claimed agents', async () => {
          const mockAgents = [
            createMockAgent({ id: 'agent-1', name: 'Agent One' }),
            createMockAgent({ id: 'agent-2', name: 'Agent Two' }),
          ];
          
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: mockAgents });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({ success: true, subscription: createMockSubscription() });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({ success: true, usage: createMockSubscriptionUsage() });
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByText('Agent One')).toBeInTheDocument();
            expect(screen.getByText('Agent Two')).toBeInTheDocument();
          });
        });
        
        it('shows empty state when no agents claimed', async () => {
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: [] });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({ success: true, subscription: createMockSubscription() });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({ success: true, usage: createMockSubscriptionUsage() });
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByText(/no.*agent/i)).toBeInTheDocument();
          });
        });
        
        it('shows agent stats (OAuth count)', async () => {
          const mockAgent = createMockAgent({ name: 'Test Agent', oauth_count: 5 });
          
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: [mockAgent] });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({ success: true, subscription: createMockSubscription() });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({ success: true, usage: createMockSubscriptionUsage() });
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByText('5')).toBeInTheDocument();
          });
        });
      });
      
      describe('Agent claim flow', () => {
        it('initiates claim with agent UUID', async () => {
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: [] });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({ success: true, subscription: createMockSubscription() });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({ success: true, usage: createMockSubscriptionUsage() });
            }),
            http.post('/v1/agents/claim/initiate', () => {
              return HttpResponse.json({
                success: true,
                challenge_id: 'challenge-123',
                complete_url: 'http://test/complete/challenge-123',
                expires_at: new Date(Date.now() + 3600000).toISOString(),
                message: 'Claim initiated',
              });
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByPlaceholderText(/agent.*uuid/i)).toBeInTheDocument();
          });
          
          await user.type(screen.getByPlaceholderText(/agent.*uuid/i), 'agent-to-claim');
          await user.click(screen.getByRole('button', { name: /claim/i }));
          
          await waitFor(() => {
            expect(screen.getByText(/challenge-123/i)).toBeInTheDocument();
          });
        });
        
        it('shows error when agent not found', async () => {
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: [] });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({ success: true, subscription: createMockSubscription() });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({ success: true, usage: createMockSubscriptionUsage() });
            }),
            http.post('/v1/agents/claim/initiate', () => {
              return HttpResponse.json(
                { error: 'Agent not found' },
                { status: 404 }
              );
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByPlaceholderText(/agent.*uuid/i)).toBeInTheDocument();
          });
          
          await user.type(screen.getByPlaceholderText(/agent.*uuid/i), 'invalid-agent');
          await user.click(screen.getByRole('button', { name: /claim/i }));
          
          await waitFor(() => {
            expect(screen.getByText(/not found/i)).toBeInTheDocument();
          });
        });
        
        it('shows error when agent already claimed', async () => {
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: [] });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({ success: true, subscription: createMockSubscription() });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({ success: true, usage: createMockSubscriptionUsage() });
            }),
            http.post('/v1/agents/claim/initiate', () => {
              return HttpResponse.json(
                { error: 'Agent already claimed by another overseer' },
                { status: 409 }
              );
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByPlaceholderText(/agent.*uuid/i)).toBeInTheDocument();
          });
          
          await user.type(screen.getByPlaceholderText(/agent.*uuid/i), 'claimed-agent');
          await user.click(screen.getByRole('button', { name: /claim/i }));
          
          await waitFor(() => {
            expect(screen.getByText(/already claimed/i)).toBeInTheDocument();
          });
        });
      });
      
      describe('Declaim agent', () => {
        it('requires confirmation before declaiming', async () => {
          const mockAgent = createMockAgent({ id: 'agent-to-declaim', name: 'To Declaim' });
          
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: [mockAgent] });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({ success: true, subscription: createMockSubscription() });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({ success: true, usage: createMockSubscriptionUsage() });
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByText('To Declaim')).toBeInTheDocument();
          });
          
          // Click declaim button
          await user.click(screen.getByRole('button', { name: /declaim/i }));
          
          // Should show confirmation
          await waitFor(() => {
            expect(screen.getByText(/confirm/i)).toBeInTheDocument();
          });
        });
        
        it('declaims agent after confirmation', async () => {
          const mockAgent = createMockAgent({ id: 'agent-to-declaim', name: 'To Declaim' });
          
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: [mockAgent] });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({ success: true, subscription: createMockSubscription() });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({ success: true, usage: createMockSubscriptionUsage() });
            }),
            http.post('/v1/agents/declaim/:agentId', () => {
              return HttpResponse.json({
                success: true,
                message: 'Agent declaimed',
                agent_id: 'agent-to-declaim',
              });
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByText('To Declaim')).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /declaim/i }));
          await user.click(screen.getByRole('button', { name: /confirm/i }));
          
          await waitFor(() => {
            expect(screen.queryByText('To Declaim')).not.toBeInTheDocument();
          });
        });
      });
      
      describe('Downgrade modal', () => {
        it('shows alert when over agent limit', async () => {
          const mockAgents = [
            createMockAgent({ id: 'agent-1' }),
            createMockAgent({ id: 'agent-2' }),
          ];
          
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: mockAgents });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({ tier: 'FREE', max_agents: 1 }),
              });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage({ agents_claimed: 2 }),
              });
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByText(/over.*limit|exceed/i)).toBeInTheDocument();
          });
        });
        
        it('opens downgrade modal when button clicked', async () => {
          const mockAgents = [
            createMockAgent({ id: 'agent-1', name: 'Agent 1' }),
            createMockAgent({ id: 'agent-2', name: 'Agent 2' }),
          ];
          
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: mockAgents });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({ tier: 'FREE', max_agents: 1 }),
              });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage({ agents_claimed: 2 }),
              });
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByText(/downgrade/i)).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /downgrade/i }));
          
          await waitFor(() => {
            expect(screen.getByText(/select.*agent|remove/i)).toBeInTheDocument();
          });
        });
        
        it('requires selecting agents to remove in downgrade modal', async () => {
          const mockAgents = [
            createMockAgent({ id: 'agent-1', name: 'Agent 1' }),
            createMockAgent({ id: 'agent-2', name: 'Agent 2' }),
          ];
          
          server.use(
            http.get('/v1/overseers/me/agents', () => {
              return HttpResponse.json({ success: true, agents: mockAgents });
            }),
            http.get('/v1/subscriptions/me', () => {
              return HttpResponse.json({
                success: true,
                subscription: createMockSubscription({ tier: 'FREE', max_agents: 1 }),
              });
            }),
            http.get('/v1/subscriptions/usage', () => {
              return HttpResponse.json({
                success: true,
                usage: createMockSubscriptionUsage({ agents_claimed: 2 }),
              });
            })
          );
          
          renderWithAllProviders(<OverseerDashboard />);
          
          await waitFor(() => {
            expect(screen.getByText(/downgrade/i)).toBeInTheDocument();
          });
          
          await user.click(screen.getByRole('button', { name: /downgrade/i }));
          
          await waitFor(() => {
            // Confirm button should be disabled until agent selected
            expect(screen.getByRole('button', { name: /remove.*selected/i })).toBeDisabled();
          });
        });
      });
    });
    ```
  </action>
  <verify>`cd frontend && npm run test:unit -- --run test/unit/pages/overseer-dashboard.test.tsx` passes</verify>
  <done>OverseerDashboard tests cover agent list, claim flow, declaim, downgrade modal</done>
</task>

</tasks>

<verification>
1. Test file exists at frontend/test/unit/pages/overseer-dashboard.test.tsx
2. Tests cover agent list, claim flow, declaim, downgrade modal
3. All tests pass
</verification>

<success_criteria>
- OverseerDashboard tests verify agent list display
- Tests cover claim initiation with success/error cases
- Tests cover declaim with confirmation flow
- Tests verify downgrade modal for over-limit scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/30-frontend-test-implementation/30-09-SUMMARY.md`
</output>