---
phase: 09-paddle-webhook-bugfix
plan: 05
type: execute
wave: 2
depends_on: [09-02]
files_modified: [backend/src/services/webhook-handler.ts, backend/src/routes/webhooks.ts]
autonomous: true

must_haves:
  truths:
    - "Paused subscriptions deactivate oversights (access suspended)"
    - "Resumed subscriptions reactivate oversights (access restored)"
    - "Past due events are handled (payment failed warning)"
  artifacts:
    - path: "backend/src/services/webhook-handler.ts"
      provides: "Subscription state change handlers"
      exports: ["handleSubscriptionPaused", "handleSubscriptionResumed", "handleSubscriptionPastDue"]
    - path: "backend/src/routes/webhooks.ts"
      provides: "Event handlers for paused/resumed/past_due"
      contains: "handleSubscriptionPaused"
  key_links:
    - from: "backend/src/routes/webhooks.ts"
      to: "backend/src/services/webhook-handler.ts"
      via: "Handler calls for paused/resumed/past_due"
      pattern: "handleSubscription(Paused|Resumed|PastDue)"
---

<objective>
Implement handlers for paused, resumed, and past_due subscription events to properly manage oversight access.

Purpose: This is Priority 5 - currently paused, resumed, trialing, and past_due events are only logged but no action is taken. This means oversights remain active even when subscription is paused or past_due, potentially granting access to non-paying users. This plan adds proper handlers for paused, resumed, and past_due events to activate/deactivate oversights appropriately.

Output: New event handlers and integration in webhooks.ts to handle subscription state changes.
</objective>

<execution_context>
@./.opencode/get-shit-done/workflows/execute-plan.md
@./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/ROADMAP.md
@.planning/phases/09-paddle-webhook-bugfix/09-RESEARCH.md

@backend/src/services/webhook-handler.ts
@backend/src/routes/webhooks.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add subscription state handlers to webhook-handler.ts</name>
  <files>backend/src/services/webhook-handler.ts</files>
  <action>
    Add the following three functions at the end of the file (after existing handlers):
    
    ```typescript
    export interface PaddlePausePayload {
      subscription_id: string;
      status: string;
    }
    
    export interface PaddleResumePayload {
      subscription_id: string;
      status: string;
    }
    
    export interface PaddlePastDuePayload {
      subscription_id: string;
      status: string;
    }
    
    /**
     * Handle subscription.paused event from Paddle
     * 
     * Deactivates all oversights when subscription is paused.
     * Access is suspended during pause period.
     * 
     * @param payload - Paddle webhook payload
     * @param db - D1 database instance
     * @param env - Environment (for consistency with other handlers)
     */
    export async function handleSubscriptionPaused(
      payload: PaddlePausePayload,
      db: D1Database,
      env: any
    ): Promise<void> {
      const { subscription_id } = payload;
      
      const drizzleDb = createDB(db);
      const overseer = await drizzleDb
        .select()
        .from(overseers)
        .where(eq(overseers.paddle_subscription_id, subscription_id))
        .limit(1);
      
      if (overseer.length === 0) {
        logSubscriptionAction('paddle_paused_no_overseer', subscription_id, {
          reason: 'Overseer not found for subscription'
        });
        return;
      }
      
      // Deactivate oversights (access suspended during pause)
      await deactivateOversight(db, overseer[0].id, 'all');
      
      logSubscriptionAction('paddle_paused', subscription_id, {
        overseer_id: overseer[0].id
      });
    }
    
    /**
     * Handle subscription.resumed event from Paddle
     * 
     * Reactivates oversights when subscription is resumed.
     * Access is restored after resume.
     * 
     * @param payload - Paddle webhook payload
     * @param db - D1 database instance
     * @param env - Environment (for consistency with other handlers)
     */
    export async function handleSubscriptionResumed(
      payload: PaddleResumePayload,
      db: D1Database,
      env: any
    ): Promise<void> {
      const { subscription_id } = payload;
      
      const drizzleDb = createDB(db);
      const overseer = await drizzleDb
        .select()
        .from(overseers)
        .where(eq(overseers.paddle_subscription_id, subscription_id))
        .limit(1);
      
      if (overseer.length === 0) {
        logSubscriptionAction('paddle_resumed_no_overseer', subscription_id, {
          reason: 'Overseer not found for subscription'
        });
        return;
      }
      
      // Reactivate oversights (access restored after resume)
      const overseerId = overseer[0].id;
      
      // Get overseer's tier to determine limit
      const customer = await getPaddleCustomer(env, overseer[0].paddle_customer_id);
      const tier = extractTierFromCustomer(customer);
      
      // Re-create oversights with correct tier
      const allAgents = await drizzleDb
        .select()
        .from(agents)
        .where(eq(agents.overseer_id, overseerId));
      
      for (const agent of allAgents) {
        await createOversight(db, overseerId, agent.id, tier);
      }
      
      logSubscriptionAction('paddle_resumed', subscription_id, {
        overseer_id: overseerId,
        tier,
        agents_count: allAgents.length
      });
    }
    
    /**
     * Handle subscription.past_due event from Paddle
     * 
     * Logs payment failure warning. Future enhancement could
     * implement a grace period before deactivation.
     * 
     * @param payload - Paddle webhook payload
     * @param db - D1 database instance
     * @param env - Environment (for consistency with other handlers)
     */
    export async function handleSubscriptionPastDue(
      payload: PaddlePastDuePayload,
      db: D1Database,
      env: any
    ): Promise<void> {
      const { subscription_id } = payload;
      
      const drizzleDb = createDB(db);
      const overseer = await drizzleDb
        .select()
        .from(overseers)
        .where(eq(overseers.paddle_subscription_id, subscription_id))
        .limit(1);
      
      if (overseer.length === 0) {
        logSubscriptionAction('paddle_past_due_no_overseer', subscription_id, {
          reason: 'Overseer not found for subscription'
        });
        return;
      }
      
      // Log warning for payment failure
      // Future enhancement: implement grace period before deactivation
      logSubscriptionAction('paddle_past_due', subscription_id, {
        overseer_id: overseer[0].id,
        warning: 'Payment failed - subscription may be canceled if not resolved'
      });
    }
    ```
    
    These handlers follow the same patterns as existing handlers (handleSubscriptionCancellation, handleTierUpdate) for consistency.
  </action>
  <verify>
    Run `grep -n "export async function handleSubscriptionPaused" backend/src/services/webhook-handler.ts` to confirm the function exists. Run `grep -n "export async function handleSubscriptionResumed" backend/src/services/webhook-handler.ts` and `grep -n "export async function handleSubscriptionPastDue" backend/src/services/webhook-handler.ts` to confirm all three functions exist.
  </verify>
  <done>
    Three new handler functions (handleSubscriptionPaused, handleSubscriptionResumed, handleSubscriptionPastDue) exist in webhook-handler.ts and are exported for use in webhooks.ts.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add handlers for paused/resumed/past_due events in webhooks.ts</name>
  <files>backend/src/routes/webhooks.ts</files>
  <action>
    1. Update imports to include new handlers:
    
    Current imports at lines 10-16:
    ```typescript
    import {
      handlePaymentSuccess,
      handleSubscriptionCancellation,
      handleTierUpdate,
      handleShadowClaimPayment,
      handleCustomerCreated
    } from '../services/webhook-handler';
    ```
    
    Replace with:
    ```typescript
    import {
      handlePaymentSuccess,
      handleSubscriptionCancellation,
      handleTierUpdate,
      handleShadowClaimPayment,
      handleCustomerCreated,
      handleSubscriptionPaused,
      handleSubscriptionResumed,
      handleSubscriptionPastDue
    } from '../services/webhook-handler';
    ```
    
    2. Update the case statements for paused, resumed, and past_due events (replace lines 131-136):
    
    Current code at lines 131-136:
    ```typescript
    // Additional subscription events - log but don't fail
    case 'subscription.paused':
    case 'subscription.resumed':
    case 'subscription.trialing':
    case 'subscription.past_due':
      console.log(`Subscription event: ${eventType} for ${eventData.subscription_id}`);
      break;
    ```
    
    Replace with:
    ```typescript
    // Subscription state changes
    case 'subscription.paused':
      await handleSubscriptionPaused(eventData, c.env.DB, c.env);
      break;
    case 'subscription.resumed':
      await handleSubscriptionResumed(eventData, c.env.DB, c.env);
      break;
    case 'subscription.past_due':
      await handleSubscriptionPastDue(eventData, c.env.DB, c.env);
      break;
    case 'subscription.trialing':
      // Trial events - log for now, may handle in future
      console.log(`Subscription event: ${eventType} for ${eventData.subscription_id}`);
      break;
    ```
    
    This replaces the log-only behavior with proper handlers for paused, resumed, and past_due events.
  </action>
  <verify>
    Run `grep -n "await handleSubscriptionPaused" backend/src/routes/webhooks.ts` to confirm the handler is called. Run `grep -n "await handleSubscriptionResumed" backend/src/routes/webhooks.ts` and `grep -n "await handleSubscriptionPastDue" backend/src/routes/webhooks.ts` to confirm all three handlers are called. Run `npm test -- backend/test/unit/webhook-handler.test.ts` to ensure tests pass.
  </verify>
  <done>
    The webhooks.ts file now calls the new handlers for paused, resumed, and past_due events instead of just logging them.
  </done>
</task>

</tasks>

<verification>
After completion, verify:
1. Three new handlers exist in webhook-handler.ts
2. All three handlers are imported in webhooks.ts
3. Case statements call appropriate handlers for paused, resumed, past_due
4. Trialing events are still logged (not handled - future work)
5. Unit tests pass
</verification>

<success_criteria>
- Paused events deactivate oversights
- Resumed events reactivate oversights
- Past due events log warnings
- Tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-paddle-webhook-bugfix/09-05-SUMMARY.md`
</output>
