---
phase: 36-client-demo-core
plan: 03
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - demo/client/client-demo.py
autonomous: true
must_haves:
  truths:
    - "User can create client assertion JWT for token endpoint authentication"
    - "User can start HTTP callback server that blocks until tokens received"
    - "Callback server handles both GET (query params) and POST (body) requests"
  artifacts:
    - path: "demo/client/client-demo.py"
      provides: "Client assertion and callback server"
      contains: "def create_client_assertion"
      contains: "class CallbackHandler"
  key_links:
    - from: "create_client_assertion()"
      to: "load_private_key()"
      via: "Ed25519 signing"
      pattern: "private_key\\.sign\\("
    - from: "CallbackHandler"
      to: "tokens"
      via: "class variable storage"
      pattern: "CallbackHandler\\.tokens"
---

<objective>
Create client assertion JWT function and blocking HTTP callback server.

Purpose: Enable private_key_jwt client authentication and token reception via HTTP callback.
Output: Working client assertion JWT generation, HTTP callback server for OAuth flow
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-client-demo-core/36-CONTEXT.md
@.planning/phases/36-client-demo-core/36-RESEARCH.md
@demo/agent/agent-demo.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create client assertion JWT function</name>
  <files>demo/client/client-demo.py</files>
  <action>
Add client assertion JWT creation to client-demo.py:

1. Import: `import time`, `import uuid`

2. Add `create_client_assertion(private_key: SigningKey, client_id: str, token_endpoint: str) -> str`:
   - JWT Header: `{"alg": "EdDSA", "typ": "JWT"}`
   - JWT Payload:
     ```
     iss: client_id       # Issuer = client_id
     sub: client_id       # Subject = client_id
     aud: token_endpoint  # Audience = token endpoint URL (NOT backend URL)
     iat: int(time.time())
     exp: int(time.time()) + 60
     jti: str(uuid.uuid4())
     ```
   - Build signing input: base64url(header).base64url(payload)
   - Sign with Ed25519 private key
   - Return complete JWT: header.payload.signature

CRITICAL DIFFERENCES from DPoP proof (in agent-demo.py):
- Header: NO jwk field, typ is "JWT" not "dpop+jwt"
- Payload: iss/sub/aud instead of htm/htu/ath
- Audience is token endpoint URL, NOT backend URL

Use base64url_encode_json for header and payload encoding.
</action>
  <verify>python3 -c "from client_demo import generate_keypair, load_private_key, create_client_assertion; priv, pub = generate_keypair(); key = load_private_key(priv); jwt = create_client_assertion(key, 'test-client-id', 'http://localhost:8787/v1/oauth/token'); parts = jwt.split('.'); assert len(parts) == 3, 'JWT must have 3 parts'; print(f'JWT created: {jwt[:50]}...')"</verify>
  <done>create_client_assertion generates valid JWT with correct claims for OAuth client authentication</done>
</task>

<task type="auto">
  <name>Task 2: Create blocking HTTP callback server</name>
  <files>demo/client/client-demo.py</files>
  <action>
Add HTTP callback server to client-demo.py:

1. Import: `from http.server import HTTPServer, BaseHTTPRequestHandler`, `import urllib.parse`

2. Add `CallbackHandler(BaseHTTPRequestHandler)` class:
   - Class variable: `tokens = None` to store captured tokens
   - `do_GET(self)`: Handle GET callback
     - Parse query params from self.path using urllib.parse
     - Extract access_token and refresh_token from query params
     - Store in CallbackHandler.tokens dict
     - Send 200 response with success message
   - `do_POST(self)`: Handle POST callback
     - Read body via self.rfile.read(content_length)
     - Parse JSON body for access_token and refresh_token
     - Store in CallbackHandler.tokens dict
     - Send 200 JSON response
   - `log_message(self, format, *args)`: Suppress default logging (pass)

3. Add `start_callback_server(hostname: str, port: int) -> dict`:
   - Create HTTPServer with (hostname, port) and CallbackHandler
   - Print "Waiting for callback at http://{hostname}:{port}/callback..."
   - Print "Press Ctrl+C to cancel."
   - Call `httpd.handle_request()` to process ONE request then return
   - Close server with `httpd.server_close()`
   - Return CallbackHandler.tokens dict

CRITICAL: Use handle_request(), NOT serve_forever() - we want to block for ONE request only.
</action>
  <verify>python3 -c "from client_demo import CallbackHandler, start_callback_server; print('CallbackHandler and start_callback_server defined')" </verify>
  <done>CallbackHandler handles GET/POST callbacks, start_callback_server blocks until one request received</done>
</task>

</tasks>

<verification>
1. Create a test JWT and verify it has correct structure (3 parts)
2. Verify JWT payload contains iss, sub, aud, iat, exp, jti claims
3. Verify callback server class exists with do_GET and do_POST methods
4. Test that handle_request() pattern is used (not serve_forever)
</verification>

<success_criteria>
- Client assertion JWT has correct header (EdDSA, JWT) and claims (iss/sub/aud)
- JWT audience is token endpoint URL (not backend URL)
- Callback server handles both GET and POST requests
- Server blocks for exactly one request then exits
</success_criteria>

<output>
After completion, create `.planning/phases/36-client-demo-core/36-03-SUMMARY.md`
</output>
