---
phase: 36-client-demo-core
plan: 04
type: execute
wave: 3
depends_on: ["36-01", "36-02", "36-03"]
files_modified:
  - demo/client/client-demo.py
autonomous: true
must_haves:
  truths:
    - "User can run 'client-demo.py generate-keys --save' to create and store keys"
    - "User can run 'client-demo.py generate-verifier' to get PKCE pair"
    - "User can run 'client-demo.py token-exchange' with required flags to complete OAuth flow"
    - "Tokens are saved to .env after successful token exchange"
  artifacts:
    - path: "demo/client/client-demo.py"
      provides: "Complete CLI for client operations"
      min_lines: 400
      contains: "def main():"
      contains: "argparse.ArgumentParser"
  key_links:
    - from: "token-exchange command"
      to: "/v1/oauth/token"
      via: "POST with client_assertion"
      pattern: "application/x-www-form-urlencoded"
    - from: "callback server"
      to: ".env"
      via: "AGENT_*_ACCESS_TOKEN storage"
      pattern: "set_key\\(ENV_FILE, f'AGENT_"
---

<objective>
Create token exchange subcommand and complete CLI interface for client-demo.py.

Purpose: Enable full OAuth flow from PKCE generation through token exchange with callback server.
Output: Working CLI with generate-keys, generate-verifier, token-exchange, and config subcommands
</objective>

<execution_context>
./.opencode/get-shit-done/workflows/execute-plan.md
./.opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-client-demo-core/36-CONTEXT.md
@.planning/phases/36-client-demo-core/36-RESEARCH.md
@demo/agent/agent-demo.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token-exchange subcommand with HTTP flow</name>
  <files>demo/client/client-demo.py</files>
  <action>
Add token exchange functionality to client-demo.py:

1. Add `make_request(url: str, headers: dict, data: Optional[bytes] = None, method: Optional[str] = None) -> str`:
   - Copy fail-fast pattern from agent-demo.py
   - On HTTPError: print raw response body to stderr, sys.exit(1)
   - On URLError: print network error to stderr, sys.exit(1)
   - Return response body as string

2. Add `print_output(response_string: str) -> None`:
   - Parse response as JSON, pretty-print with indent=2

3. Add `cmd_generate_keys(args) -> int`:
   - Generate keypair using generate_keypair()
   - If --save flag: save to .env via set_key for CLIENT_PRIVATE_KEY and CLIENT_PUBLIC_KEY
   - Print output (keys or confirmation)
   - Return 0 on success, 1 on error

4. Add `cmd_generate_verifier(args) -> int`:
   - Generate PKCE pair using generate_pkce_pair()
   - Print JSON with code_verifier, code_challenge, code_challenge_method="S256"
   - Return 0

5. Add `cmd_token_exchange(args) -> int`:
   - Load config via load_config()
   - Validate config has backend_url, client_id, private_key
   - Build redirect_uri: `http://{client_url}:{client_port}/callback`
   - Build token_endpoint: `{backend_url}/v1/oauth/token`
   - Load private key and create client_assertion JWT
   - Start callback server in the SAME process (it will block)
   - BUT FIRST: make the token exchange request
   - The backend will redirect to callback URL with tokens
   - After server returns: extract tokens from CallbackHandler.tokens
   - Save tokens to .env as AGENT_{agent_id}_ACCESS_TOKEN and AGENT_{agent_id}_REFRESH_TOKEN
   - Print token response
   - Return 0 on success, 1 on error

IMPORTANT: Per CONTEXT.md, token exchange uses application/x-www-form-urlencoded encoding.
Use urllib.parse.urlencode() for the request body.

Token exchange body fields:
- grant_type: "authorization_code"
- code: from --token flag
- redirect_uri: constructed callback URL
- client_id: from config
- client_assertion: JWT created from client's private key
- client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
- code_verifier: from --code-verifier flag

The --agent-id flag specifies which agent namespace to use for token storage.
</action>
  <verify>python3 -c "from client_demo import cmd_generate_keys, cmd_generate_verifier, cmd_token_exchange; print('Token exchange command defined')"</verify>
  <done>generate-keys, generate-verifier, and token-exchange commands function correctly</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI with argparse and config subcommand</name>
  <files>demo/client/client-demo.py</files>
  <action>
Add CLI implementation to client-demo.py:

1. Add `cmd_config(args) -> int`:
   - Load config via load_config()
   - If --backend-url provided: update config
   - If --client-id provided: update config
   - If both --private-key and --public-key provided: validate and update
   - If --client-url provided: update config
   - If --client-port provided: update config
   - Save config if any updates
   - Print current configuration (mask private key partially)
   - Print validation status
   - Return 0

2. Add `main()` function:
   - Create ArgumentParser with description "Client-ID Demo Script"
   - Create subparsers for: generate-keys, generate-verifier, token-exchange, config
   
   - generate-keys parser:
     - --save flag: Save generated keys to .env
   
   - generate-verifier parser:
     - No arguments (just outputs PKCE pair)
   
   - token-exchange parser:
     - --token: Authorization code (required)
     - --code-verifier: PKCE code verifier (required)
     - --agent-id: Agent ID for token storage (required)
   
   - config parser:
     - --backend-url
     - --client-id
     - --private-key
     - --public-key
     - --client-url
     - --client-port
   
   - Parse args and dispatch to command handlers
   - Return exit code from handler

3. Add `if __name__ == "__main__": sys.exit(main())`

4. Import argparse, sys at the top
</action>
  <verify>python3 demo/client/client-demo.py --help</verify>
  <done>CLI works with --help showing all subcommands, each subcommand shows its options</done>
</task>

</tasks>

<verification>
1. Run `python3 demo/client/client-demo.py --help` - shows usage
2. Run `python3 demo/client/client-demo.py generate-keys --help` - shows save option
3. Run `python3 demo/client/client-demo.py generate-verifier --help` - shows usage
4. Run `python3 demo/client/client-demo.py token-exchange --help` - shows required flags
5. Run `python3 demo/client/client-demo.py config --help` - shows all options
6. Test generate-keys creates valid keys
7. Test generate-verifier creates valid PKCE pair
8. Test config shows current configuration
</verification>

<success_criteria>
- CLI has generate-keys, generate-verifier, token-exchange, config subcommands
- generate-keys supports --save flag for .env storage
- generate-verifier outputs JSON with verifier, challenge, method
- token-exchange requires --token, --code-verifier, --agent-id flags
- config shows and updates configuration with proper validation
- All commands follow agent-demo.py patterns for consistency
</success_criteria>

<output>
After completion, create `.planning/phases/36-client-demo-core/36-04-SUMMARY.md`
</output>
